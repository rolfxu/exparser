/* ExparserImpl.java */
/* Generated By:JavaCC: Do not edit this line. ExparserImpl.java */
package com.yunpayroll.exparser.parser;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Reader;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

import com.google.common.collect.Lists;

/**
 * Express parser, generated from Parser.jj by JavaCC.
 *
 */
public class ExparserImpl implements ExparserImplConstants {
    private static final Logger LOGGER = LoggerFactory.getLogger(ExparserImpl.class);

    // Can't use quoted literal because of a bug in how JavaCC translates
    // backslash-backslash.
    private static final char BACKSLASH = 0x5c;
    private static final char DOUBLE_QUOTE = 0x22;
    private static final String DQ = DOUBLE_QUOTE + "";
    private static final String DQDQ = DQ + DQ;



    public static final ParserImplFactory FACTORY = new ParserImplFactory() {
        public ExparserImpl getParser(Reader reader) {
            final ExparserImpl parser = new ExparserImpl(reader);
          return parser;
        }
    };

    public ParseException normalizeException(Throwable ex) {
        try {
            if (ex instanceof ParseException) {
                ex = cleanupParseException((ParseException) ex);
            }
            return convertException(ex);
        } catch (ParseException e) {
            throw new AssertionError(e);
        }
    }



    public void setTabSize(int tabSize) {
        jj_input_stream.setTabSize(tabSize);
    }




    public Node parseExpressionEof() throws Exception {
        return ExpressionEof();
    }

  void debug_message1() throws ParseException {LOGGER.info("{} , {}", getToken(0).image, getToken(1).image);
  }

  String unquotedIdentifier() throws ParseException {return getToken(0).image;
  }

  void E() throws ParseException {
  }

  List startList(Object o) throws ParseException {List list = new ArrayList();
    list.add(o);
    return list;
  }

  protected ParserPos getPos() throws ParseException {return new ParserPos(
        token.beginLine,
        token.beginColumn,
        token.endLine,
        token.endColumn);
  }

  ParseException convertException(Throwable ex) throws ParseException {if (ex instanceof ParseException) {
        return (ParseException) ex;
    }
    int[][] expectedTokenSequences = null;
    String[] tokenImage = null;
    if (ex instanceof ParseException) {
        ParseException pex = (ParseException) ex;
        expectedTokenSequences = pex.expectedTokenSequences;
        tokenImage = pex.tokenImage;
        if (pex.currentToken != null) {
            final Token token = pex.currentToken.next;

        }
    } else if (ex instanceof TokenMgrError) {
        TokenMgrError tme = (TokenMgrError) ex;
        expectedTokenSequences = null;
        tokenImage = null;
        // Example:
        //    Lexical error at line 3, column 24.  Encountered "#" after "a".
        final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(
            "(?s)Lexical error at line ([0-9]+), column ([0-9]+).*");
        java.util.regex.Matcher matcher = pattern.matcher(ex.getMessage());
        if (matcher.matches()) {
            int line = Integer.parseInt(matcher.group(1));
            int column = Integer.parseInt(matcher.group(2));
        }
    }

    return new ParseException(
        ex.getMessage());
  }

  ParseException cleanupParseException(ParseException ex) throws ParseException {if (ex.expectedTokenSequences == null) {
        return ex;
    }
    int iIdentifier = Arrays.asList(ex.tokenImage).indexOf("<IDENTIFIER>");

    // Find all sequences in the error which contain identifier. For
    // example,
    //       {<IDENTIFIER>}
    //       {A}
    //       {B, C}
    //       {D, <IDENTIFIER>}
    //       {D, A}
    //       {D, B}
    //
    // would yield
    //       {}
    //       {D}
    boolean id = false;
    final List<int[]> prefixList = new ArrayList<int[]>();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int[] seq = ex.expectedTokenSequences[i];
        int j = seq.length - 1;
        int i1 = seq[j];
        if (i1 == iIdentifier) {
            int[] prefix = new int[j];
            System.arraycopy(seq, 0, prefix, 0, j);
            prefixList.add(prefix);
        }
    }

    if (prefixList.isEmpty()) {
        return ex;
    }

    int[][] prefixes = (int[][])
        prefixList.toArray(new int[prefixList.size()][]);

    // Since <IDENTIFIER> was one of the possible productions,
    // we know that the parser will also have included all
    // of the non-reserved keywords (which are treated as
    // identifiers in non-keyword contexts).  So, now we need
    // to clean those out, since they're totally irrelevant.

    final List<int[]> list = new ArrayList<int[]>();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int [] seq = ex.expectedTokenSequences[i];
        String tokenImage = ex.tokenImage[seq[seq.length - 1]];
        String token = SqlParserUtil.getTokenVal(tokenImage);
        if (token == null ) {
            list.add(seq);
            continue;
        }
        boolean match = matchesPrefix(seq, prefixes);
        if (!match) {
            list.add(seq);
        }
    }

    ex.expectedTokenSequences =
        (int [][]) list.toArray(new int [list.size()][]);
    return ex;
  }

  Span span() throws ParseException {return Span.of(getPos());
  }

  boolean matchesPrefix(int[] seq, int[][] prefixes) throws ParseException {nextPrefix:
    for (int[] prefix : prefixes) {
        if (seq.length == prefix.length + 1) {
            for (int k = 0; k < prefix.length; k++) {
                if (prefix[k] != seq[k]) {
                    continue nextPrefix;
                }
            }
            return true;
        }
    }
    return false;
  }

  final public Node ParenthesizedQueryOrCommaList() throws ParseException {Node e;
    final Span s = span();
    jj_consume_token(LPAREN);
    e = Expression();
    jj_consume_token(RPAREN);
ParenthesizedNode node = new ParenthesizedNode(s.end(this));
        node.setNode(e);
        {if ("" != null) return node;}
    throw new Error("Missing return statement in function");
}

/**
 * Parses function parameter lists including DISTINCT keyword recognition,
 * DEFAULT, and named argument assignment.
 */
  final public List FunctionParameterList() throws ParseException {Node e = null;
    List list = new ArrayList();
    jj_consume_token(LPAREN);
    e = Expression();
list.add(e);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(COMMA);
      e = Expression();
list.add(e);
    }
    jj_consume_token(RPAREN);
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
}

//void Arg0(List list) :
//{
//    Identifier name = null;
//    Node e = null;
//}
//{
//    [
//        LOOKAHEAD(2) name = SimpleIdentifier() <NAMED_ARGUMENT_ASSIGNMENT>
//    ]
//
//    {
//        if (e != null) {
//            if (name != null) {
//                e = SqlStdOperatorTable.ARGUMENT_ASSIGNMENT.createCall(
//                    Span.of(name, e).pos(), e, name);
//            }
//            list.add(e);
//        }
//    }
//}
//
//void Arg(List list) :
//{
//    Identifier name = null;
//    Node e = null;
//}
//{
//    [
//        LOOKAHEAD(2) name = SimpleIdentifier() <NAMED_ARGUMENT_ASSIGNMENT>
//    ]
//    (
//        e = Expression()
//    )
//    {
//        if (e != null) {
//            if (name != null) {
//                e = SqlStdOperatorTable.ARGUMENT_ASSIGNMENT.createCall(
//                    Span.of(name, e).pos(), e, name);
//            }
//            list.add(e);
//        }
//    }
//}






/**
 * Parses a list of expressions separated by commas.
 */
  final public NodeList ExpressionCommaList(Span s) throws ParseException {List<Node> list;
    Node e;
    e = Expression();
list = startList(e);
    label_2:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_2;
      }
      jj_consume_token(COMMA);
      e = Expression();
list.add(e);
    }
{if ("" != null) return null;}
    throw new Error("Missing return statement in function");
}

  final public Node ExpressionEof() throws ParseException {Node e;
    e = Expression();
    jj_consume_token(0);
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
}

/**
 * Parses a row expression or a parenthesized expression of any kind.
 */
  final public Node Expression() throws ParseException {List<Object> list1;
    Node e;
    list1 = Expression2();
e = SqlParserUtil.toTree(list1);
        {if ("" != null) return e;}
    throw new Error("Missing return statement in function");
}

  final public void Expression2b(List<Object> list) throws ParseException {Node e;
    Node ext;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_3;
      }
        SqlParserUtil.ToTreeListItem op = PrefixRowOperator();
list.add(op);
    }
    e = Expression3();
list.add(e);
    label_4:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(DOT);
      ext = RowExpressionExtension();
list.add(ext);
    }
}

/**
 * Parses a binary row expression, or a parenthesized expression of any
 * kind.
 *
 * <p>The result is as a flat list of operators and operands. The top-level
 * call to get an expression should call {@link #Expression}, but lower-level
 * calls should call this, to give the parser the opportunity to associate
 * operator calls.
 *
 * <p>For example 'a = b like c = d' should come out '((a = b) like c) = d'
 * because LIKE and '=' have the same precedence, but tends to come out as '(a
 * = b) like (c = d)' because (a = b) and (c = d) are parsed as separate
 * expressions.
 */
  final public List<Object> Expression2() throws ParseException {final List<Object> list = new ArrayList();
    List<Object> list2;
    final List<Object> list3 = new ArrayList();
    Node parenthesized;
    Node e=null;
    Operator op;
    Identifier p;
    final Span s = span();
    Expression2b(list);
    if (jj_2_5(2)) {
      label_5:
      while (true) {
        if (jj_2_4(3)) {
          op = BinaryRowOperator();
list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
          Expression2b(list);
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACKET:{
            jj_consume_token(LBRACKET);
            e = Expression();
            jj_consume_token(RBRACKET);
list.add(e);
            label_6:
            while (true) {
              if (jj_2_3(2)) {
                ;
              } else {
                break label_6;
              }
              jj_consume_token(DOT);
              p = SimpleIdentifier();
list.add(p);
            }
            break;
            }
          default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LBRACKET:
        case EQ:
        case GT:
        case LT:
        case LE:
        case GE:
        case NE:
        case NE2:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case PERCENT_REMAINDER:{
          ;
          break;
          }
        default:
          jj_la1[3] = jj_gen;
          break label_5;
        }
      }
{if ("" != null) return list;}
    } else {
{if ("" != null) return list;}
    }
    throw new Error("Missing return statement in function");
}

/** Parses a comparison operator inside a SOME / ALL predicate. */
  final public SqlKind comp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
      jj_consume_token(LT);
{if ("" != null) return SqlKind.LESS_THAN;}
      break;
      }
    case LE:{
      jj_consume_token(LE);
{if ("" != null) return SqlKind.LESS_THAN_OR_EQUAL;}
      break;
      }
    case GT:{
      jj_consume_token(GT);
{if ("" != null) return SqlKind.GREATER_THAN;}
      break;
      }
    case GE:{
      jj_consume_token(GE);
{if ("" != null) return SqlKind.GREATER_THAN_OR_EQUAL;}
      break;
      }
    case EQ:{
      jj_consume_token(EQ);
{if ("" != null) return SqlKind.EQUALS;}
      break;
      }
    case NE:{
      jj_consume_token(NE);
{if ("" != null) return SqlKind.NOT_EQUALS;}
      break;
      }
    case NE2:{
      jj_consume_token(NE2);
{if ("" != null) return SqlKind.NOT_EQUALS;}
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/**
 * Parses a unary row expression, or a parenthesized expression of any
 * kind.
 */
  final public Node Expression3() throws ParseException {final Node e;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case A:
    case ABS:
    case ABSENT:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case APPLY:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case AVG:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CARDINALITY:
    case CASCADE:
    case CASE:
    case CATALOG:
    case CATALOG_NAME:
    case CEILING:
    case CENTURY:
    case CHAIN:
    case CHAR_LENGTH:
    case CHARACTER_LENGTH:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COALESCE:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLLECT:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITIONAL:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTINUE:
    case COUNT:
    case COVAR_POP:
    case COVAR_SAMP:
    case CUME_DIST:
    case CURRENT_CATALOG:
    case CURRENT_DATE:
    case CURRENT_DEFAULT_TRANSFORM_GROUP:
    case CURRENT_PATH:
    case CURRENT_ROLE:
    case CURRENT_SCHEMA:
    case CURRENT_TIME:
    case CURRENT_TIMESTAMP:
    case CURRENT_USER:
    case CURSOR_NAME:
    case DATA:
    case DATABASE:
    case DATE:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DECADE:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DENSE_RANK:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DOW:
    case DOY:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case ELEMENT:
    case ENCODING:
    case EPOCH:
    case ERROR:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case EXP:
    case FALSE:
    case FINAL:
    case FIRST:
    case FIRST_VALUE:
    case FLOOR:
    case FOLLOWING:
    case FORMAT:
    case FORTRAN:
    case FOUND:
    case FRAC_SECOND:
    case FUSION:
    case G:
    case GENERAL:
    case GENERATED:
    case GEOMETRY:
    case GO:
    case GOTO:
    case GRANTED:
    case GROUPING:
    case HIERARCHY:
    case HOUR:
    case IGNORE:
    case IMMEDIATE:
    case IMMEDIATELY:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISODOW:
    case ISOYEAR:
    case ISOLATION:
    case JAVA:
    case JSON:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAG:
    case LAST:
    case LAST_VALUE:
    case LEAD:
    case LEFT:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LN:
    case LOCALTIME:
    case LOCALTIMESTAMP:
    case LOCATOR:
    case LOWER:
    case M:
    case MAP:
    case MATCHED:
    case MAX:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MICROSECOND:
    case MILLISECOND:
    case MILLENNIUM:
    case MIN:
    case MINUTE:
    case MINVALUE:
    case MOD:
    case MONTH:
    case MORE_:
    case MUMPS:
    case NAME:
    case NAMES:
    case NANOSECOND:
    case NESTING:
    case NORMALIZED:
    case NTH_VALUE:
    case NTILE:
    case NULLABLE:
    case NULLIF:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTET_LENGTH:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSING:
    case PASSTHROUGH:
    case PAST:
    case PATH:
    case PERCENT_RANK:
    case PLACING:
    case PLAN:
    case PLI:
    case POWER:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case QUARTER:
    case RANK:
    case READ:
    case REGR_COUNT:
    case REGR_SXX:
    case REGR_SYY:
    case RELATIVE:
    case REPEATABLE:
    case REPLACE:
    case RESPECT:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case RETURNING:
    case RIGHT:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case ROW_NUMBER:
    case SCALAR:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECOND:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SESSION_USER:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case SQL_BIGINT:
    case SQL_BINARY:
    case SQL_BIT:
    case SQL_BLOB:
    case SQL_BOOLEAN:
    case SQL_CHAR:
    case SQL_CLOB:
    case SQL_DATE:
    case SQL_DECIMAL:
    case SQL_DOUBLE:
    case SQL_FLOAT:
    case SQL_INTEGER:
    case SQL_INTERVAL_DAY:
    case SQL_INTERVAL_DAY_TO_HOUR:
    case SQL_INTERVAL_DAY_TO_MINUTE:
    case SQL_INTERVAL_DAY_TO_SECOND:
    case SQL_INTERVAL_HOUR:
    case SQL_INTERVAL_HOUR_TO_MINUTE:
    case SQL_INTERVAL_HOUR_TO_SECOND:
    case SQL_INTERVAL_MINUTE:
    case SQL_INTERVAL_MINUTE_TO_SECOND:
    case SQL_INTERVAL_MONTH:
    case SQL_INTERVAL_SECOND:
    case SQL_INTERVAL_YEAR:
    case SQL_INTERVAL_YEAR_TO_MONTH:
    case SQL_LONGVARBINARY:
    case SQL_LONGVARCHAR:
    case SQL_LONGVARNCHAR:
    case SQL_NCHAR:
    case SQL_NCLOB:
    case SQL_NUMERIC:
    case SQL_NVARCHAR:
    case SQL_REAL:
    case SQL_SMALLINT:
    case SQL_TIME:
    case SQL_TIMESTAMP:
    case SQL_TINYINT:
    case SQL_TSI_DAY:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_HOUR:
    case SQL_TSI_MICROSECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_SECOND:
    case SQL_TSI_WEEK:
    case SQL_TSI_YEAR:
    case SQL_VARBINARY:
    case SQL_VARCHAR:
    case SQRT:
    case STATE:
    case STATEMENT:
    case STDDEV_POP:
    case STDDEV_SAMP:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case SUM:
    case SYSTEM_USER:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TRUE:
    case TRUNCATE:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNCONDITIONAL:
    case UNDER:
    case UNNAMED:
    case UPPER:
    case USAGE:
    case USER:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case UTF8:
    case UTF16:
    case UTF32:
    case VAR_POP:
    case VAR_SAMP:
    case VERSION:
    case VIEW:
    case WEEK:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case YEAR:
    case ZONE:
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:
    case QUOTED_STRING:
    case DOUBLE_QUOTED_STRING:
    case LBRACE_D:
    case LBRACE_T:
    case LBRACE_TS:
    case PLUS:
    case MINUS:
    case BRACKET_QUOTED_IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case BACK_QUOTED_IDENTIFIER:
    case IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:{
      e = AtomicRowExpression();
{if ("" != null) return e;}
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      if (jj_2_6(2)) {
        e = ParenthesizedQueryOrCommaList();
{if ("" != null) return e;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
}

/**
 * Numeric literal or parameter; used in LIMIT, OFFSET and FETCH clauses.
 */
  final public Node UnsignedNumericLiteralOrParam() throws ParseException {final Node e;
    e = UnsignedNumericLiteral();
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
}

/**
 * Parses a row expression extension, it can be either an identifier,
 * or a call to a named function.
 */
  final public Node RowExpressionExtension() throws ParseException {final Identifier p;
    final Span s;
    final List<Node> args;
    Node e;
    Literal quantifier = null;
    p = SimpleIdentifier();
e = p;
    if (jj_2_7(2)) {
      jj_consume_token(LPAREN);
      jj_consume_token(RPAREN);
args = Collections.emptyList();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        args = FunctionParameterList();
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
e = null;
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
}

/**
 * Parses an atomic row expression.
 */
  final public Node AtomicRowExpression() throws ParseException {final Node e;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DATE:
    case FALSE:
    case TIME:
    case TIMESTAMP:
    case TRUE:
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:
    case QUOTED_STRING:
    case DOUBLE_QUOTED_STRING:
    case LBRACE_D:
    case LBRACE_T:
    case LBRACE_TS:
    case PLUS:
    case MINUS:{
      e = Literal();
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      if (jj_2_8(2147483647)) {
        e = NamedFunctionCall();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CURRENT_CATALOG:
        case CURRENT_DATE:
        case CURRENT_DEFAULT_TRANSFORM_GROUP:
        case CURRENT_PATH:
        case CURRENT_ROLE:
        case CURRENT_SCHEMA:
        case CURRENT_TIME:
        case CURRENT_TIMESTAMP:
        case CURRENT_USER:
        case LOCALTIME:
        case LOCALTIMESTAMP:
        case SESSION_USER:
        case SYSTEM_USER:
        case USER:{
          e = ContextVariable();
          break;
          }
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DECADE:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IGNORE:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESPECT:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          e = CompoundIdentifier();
          break;
          }
        case CASE:{
          e = CaseExpression();
          break;
          }
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
}

  final public Node CaseExpression() throws ParseException {final Span whenSpan = Span.of();
    final Span thenSpan = Span.of();
    final Span s;
    Node e;
    Node caseIdentifier = null;
    Node elseClause = null;
    List<Node> whenList = new ArrayList<Node>();
    List<Node> thenList = new ArrayList<Node>();
    jj_consume_token(CASE);
s = span();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case A:
    case ABS:
    case ABSENT:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case APPLY:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case AVG:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CARDINALITY:
    case CASCADE:
    case CASE:
    case CATALOG:
    case CATALOG_NAME:
    case CEILING:
    case CENTURY:
    case CHAIN:
    case CHAR_LENGTH:
    case CHARACTER_LENGTH:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COALESCE:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLLECT:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITIONAL:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTINUE:
    case COUNT:
    case COVAR_POP:
    case COVAR_SAMP:
    case CUME_DIST:
    case CURRENT_CATALOG:
    case CURRENT_DATE:
    case CURRENT_DEFAULT_TRANSFORM_GROUP:
    case CURRENT_PATH:
    case CURRENT_ROLE:
    case CURRENT_SCHEMA:
    case CURRENT_TIME:
    case CURRENT_TIMESTAMP:
    case CURRENT_USER:
    case CURSOR_NAME:
    case DATA:
    case DATABASE:
    case DATE:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DECADE:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DENSE_RANK:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DOW:
    case DOY:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case ELEMENT:
    case ENCODING:
    case EPOCH:
    case ERROR:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case EXP:
    case FALSE:
    case FINAL:
    case FIRST:
    case FIRST_VALUE:
    case FLOOR:
    case FOLLOWING:
    case FORMAT:
    case FORTRAN:
    case FOUND:
    case FRAC_SECOND:
    case FUSION:
    case G:
    case GENERAL:
    case GENERATED:
    case GEOMETRY:
    case GO:
    case GOTO:
    case GRANTED:
    case GROUPING:
    case HIERARCHY:
    case HOUR:
    case IGNORE:
    case IMMEDIATE:
    case IMMEDIATELY:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISODOW:
    case ISOYEAR:
    case ISOLATION:
    case JAVA:
    case JSON:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAG:
    case LAST:
    case LAST_VALUE:
    case LEAD:
    case LEFT:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LN:
    case LOCALTIME:
    case LOCALTIMESTAMP:
    case LOCATOR:
    case LOWER:
    case M:
    case MAP:
    case MATCHED:
    case MAX:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MICROSECOND:
    case MILLISECOND:
    case MILLENNIUM:
    case MIN:
    case MINUTE:
    case MINVALUE:
    case MOD:
    case MONTH:
    case MORE_:
    case MUMPS:
    case NAME:
    case NAMES:
    case NANOSECOND:
    case NESTING:
    case NORMALIZED:
    case NTH_VALUE:
    case NTILE:
    case NULLABLE:
    case NULLIF:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTET_LENGTH:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSING:
    case PASSTHROUGH:
    case PAST:
    case PATH:
    case PERCENT_RANK:
    case PLACING:
    case PLAN:
    case PLI:
    case POWER:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case QUARTER:
    case RANK:
    case READ:
    case REGR_COUNT:
    case REGR_SXX:
    case REGR_SYY:
    case RELATIVE:
    case REPEATABLE:
    case REPLACE:
    case RESPECT:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case RETURNING:
    case RIGHT:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case ROW_NUMBER:
    case SCALAR:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECOND:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SESSION_USER:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case SQL_BIGINT:
    case SQL_BINARY:
    case SQL_BIT:
    case SQL_BLOB:
    case SQL_BOOLEAN:
    case SQL_CHAR:
    case SQL_CLOB:
    case SQL_DATE:
    case SQL_DECIMAL:
    case SQL_DOUBLE:
    case SQL_FLOAT:
    case SQL_INTEGER:
    case SQL_INTERVAL_DAY:
    case SQL_INTERVAL_DAY_TO_HOUR:
    case SQL_INTERVAL_DAY_TO_MINUTE:
    case SQL_INTERVAL_DAY_TO_SECOND:
    case SQL_INTERVAL_HOUR:
    case SQL_INTERVAL_HOUR_TO_MINUTE:
    case SQL_INTERVAL_HOUR_TO_SECOND:
    case SQL_INTERVAL_MINUTE:
    case SQL_INTERVAL_MINUTE_TO_SECOND:
    case SQL_INTERVAL_MONTH:
    case SQL_INTERVAL_SECOND:
    case SQL_INTERVAL_YEAR:
    case SQL_INTERVAL_YEAR_TO_MONTH:
    case SQL_LONGVARBINARY:
    case SQL_LONGVARCHAR:
    case SQL_LONGVARNCHAR:
    case SQL_NCHAR:
    case SQL_NCLOB:
    case SQL_NUMERIC:
    case SQL_NVARCHAR:
    case SQL_REAL:
    case SQL_SMALLINT:
    case SQL_TIME:
    case SQL_TIMESTAMP:
    case SQL_TINYINT:
    case SQL_TSI_DAY:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_HOUR:
    case SQL_TSI_MICROSECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_SECOND:
    case SQL_TSI_WEEK:
    case SQL_TSI_YEAR:
    case SQL_VARBINARY:
    case SQL_VARCHAR:
    case SQRT:
    case STATE:
    case STATEMENT:
    case STDDEV_POP:
    case STDDEV_SAMP:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case SUM:
    case SYSTEM_USER:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TIME:
    case TIMESTAMP:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TRUE:
    case TRUNCATE:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNCONDITIONAL:
    case UNDER:
    case UNNAMED:
    case UPPER:
    case USAGE:
    case USER:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case UTF8:
    case UTF16:
    case UTF32:
    case VAR_POP:
    case VAR_SAMP:
    case VERSION:
    case VIEW:
    case WEEK:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case YEAR:
    case ZONE:
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:
    case QUOTED_STRING:
    case DOUBLE_QUOTED_STRING:
    case LPAREN:
    case LBRACE_D:
    case LBRACE_T:
    case LBRACE_TS:
    case PLUS:
    case MINUS:
    case BRACKET_QUOTED_IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case BACK_QUOTED_IDENTIFIER:
    case IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:{
      caseIdentifier = Expression();
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    label_7:
    while (true) {
      jj_consume_token(WHEN);
whenSpan.add(this);
      e = ExpressionCommaList(s);
if (((NodeList) e).size() == 1) {
                e = ((NodeList) e).get(0);
            }
            whenList.add(e);
      jj_consume_token(THEN);
thenSpan.add(this);
      e = Expression();
thenList.add(e);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WHEN:{
        ;
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        break label_7;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ELSE:{
      jj_consume_token(ELSE);
      elseClause = Expression();
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    jj_consume_token(END);
{if ("" != null) return null;}
    throw new Error("Missing return statement in function");
}

/**
 * Parses a literal expression, allowing continued string literals.
 * Usually returns an SqlLiteral, but a continued string literal
 * is an SqlCall expression, which concatenates 2 or more string
 * literals; the validator reduces this.
 */
  final public Node Literal() throws ParseException {Node e;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:
    case PLUS:
    case MINUS:{
      e = NumericLiteral();
      break;
      }
    case QUOTED_STRING:{
      e = StringLiteral();
      break;
      }
    case DOUBLE_QUOTED_STRING:{
      e = StringLiteral2();
      break;
      }
    case FALSE:
    case TRUE:{
      e = SpecialLiteral();
      break;
      }
    case DATE:
    case TIME:
    case TIMESTAMP:
    case LBRACE_D:
    case LBRACE_T:
    case LBRACE_TS:{
      e = DateTimeLiteral();
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
}

/** Parses a unsigned numeric literal */
  final public NumericLiteral UnsignedNumericLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER_LITERAL:{
      jj_consume_token(UNSIGNED_INTEGER_LITERAL);
{if ("" != null) return Literal.createExactNumeric(token.image, getPos());}
      break;
      }
    case DECIMAL_NUMERIC_LITERAL:{
      jj_consume_token(DECIMAL_NUMERIC_LITERAL);
{if ("" != null) return Literal.createExactNumeric(token.image, getPos());}
      break;
      }
    case APPROX_NUMERIC_LITERAL:{
      jj_consume_token(APPROX_NUMERIC_LITERAL);
{if ("" != null) return Literal.createApproxNumeric(token.image, getPos());}
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/** Parses a numeric literal (can be signed) */
  final public Literal NumericLiteral() throws ParseException {final NumericLiteral num;
    final Span s;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PLUS:{
      jj_consume_token(PLUS);
      num = UnsignedNumericLiteral();
{if ("" != null) return num;}
      break;
      }
    case MINUS:{
      jj_consume_token(MINUS);
s = span();
      num = UnsignedNumericLiteral();
{if ("" != null) return Literal.createNegative(num, s.end(this));}
      break;
      }
    case UNSIGNED_INTEGER_LITERAL:
    case APPROX_NUMERIC_LITERAL:
    case DECIMAL_NUMERIC_LITERAL:{
      num = UnsignedNumericLiteral();
{if ("" != null) return num;}
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/** Parse a special literal keyword */
  final public Literal SpecialLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:{
      jj_consume_token(TRUE);
{if ("" != null) return Literal.createBoolean(true, getPos());}
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
{if ("" != null) return Literal.createBoolean(false, getPos());}
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  final public Node StringLiteral() throws ParseException {String p;
    int nfrags = 0;
    List<Literal> frags = null;
    Literal literal = null;
    char unicodeEscapeChar = 0;
    jj_consume_token(QUOTED_STRING);
p = token.image;
        try {
            literal = Literal.createCharString(p, null, getPos());
        } catch (java.nio.charset.UnsupportedCharsetException e) {
            {if (true) throw e;}
        }
        frags = startList(literal);
        nfrags++;
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case QUOTED_STRING:{
        ;
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        break label_8;
      }
      jj_consume_token(QUOTED_STRING);
p = token.image;
            try {
                literal = Literal.createCharString(p, null, getPos());
            } catch (java.nio.charset.UnsupportedCharsetException e) {
                {if (true) throw e;}
            }
            frags.add(literal);
            nfrags++;
    }
assert nfrags > 0;
        if (nfrags == 1) {
            // just the head fragment
            Literal lit = (Literal) frags.get(0);
            {if ("" != null) return lit;}
        } else {
            Node[] rands = (Node[]) frags.toArray(new Node[nfrags]);
            ParserPos pos2 = ParserPos.sum(rands);
            {if ("" != null) return rands[0];}
        }
    throw new Error("Missing return statement in function");
}

  final public Node StringLiteral2() throws ParseException {String p;
    int nfrags = 0;
    List<Literal> frags = null;
    Literal literal = null;
    char unicodeEscapeChar = 0;
    jj_consume_token(DOUBLE_QUOTED_STRING);
p = token.image;
        try {
            literal = Literal.createCharString(p, null, getPos());
        } catch (java.nio.charset.UnsupportedCharsetException e) {
            {if (true) throw e;}
        }
        frags = startList(literal);
        nfrags++;
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOUBLE_QUOTED_STRING:{
        ;
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        break label_9;
      }
      jj_consume_token(DOUBLE_QUOTED_STRING);
p = token.image;
            try {
                literal = Literal.createCharString(p, null, getPos());
            } catch (java.nio.charset.UnsupportedCharsetException e) {
                {if (true) throw e;}
            }
            frags.add(literal);
            nfrags++;
    }
assert nfrags > 0;
        if (nfrags == 1) {
            // just the head fragment
            Literal lit = (Literal) frags.get(0);
            {if ("" != null) return lit;}
        } else {
            Node[] rands = (Node[]) frags.toArray(new Node[nfrags]);
            ParserPos pos2 = ParserPos.sum(rands);
            {if ("" != null) return rands[0];}
        }
    throw new Error("Missing return statement in function");
}

/**
 * Parses a date/time literal.
 */
  final public Literal DateTimeLiteral() throws ParseException {String  p=null;
    final Span s;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE_D:{
      jj_consume_token(LBRACE_D);
      jj_consume_token(QUOTED_STRING);
p = token.image;
      jj_consume_token(RBRACE);
{if ("" != null) return new CharStringLiteral(getPos(),p );}
      break;
      }
    case LBRACE_T:{
      jj_consume_token(LBRACE_T);
      jj_consume_token(QUOTED_STRING);
p = token.image;
      jj_consume_token(RBRACE);
{if ("" != null) return new CharStringLiteral(getPos(),p );}
      break;
      }
    case LBRACE_TS:{
      jj_consume_token(LBRACE_TS);
s = span();
      jj_consume_token(QUOTED_STRING);
p = token.image;
      jj_consume_token(RBRACE);
{if ("" != null) return new CharStringLiteral(s.end(this),p );}
      break;
      }
    case DATE:{
      jj_consume_token(DATE);
s = span();
      jj_consume_token(QUOTED_STRING);
{if ("" != null) return new CharStringLiteral(s.end(this),p );}
      break;
      }
    case TIME:{
      jj_consume_token(TIME);
s = span();
      jj_consume_token(QUOTED_STRING);
{if ("" != null) return new CharStringLiteral(s.end(this),p );}
      break;
      }
    case TIMESTAMP:{
      jj_consume_token(TIMESTAMP);
s = span();
      jj_consume_token(QUOTED_STRING);
{if ("" != null) return new CharStringLiteral(s.end(this),p );}
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/**
 * Parses one segment of an identifier that may be composite.
 *
 * <p>Each time it reads an identifier it writes one element to each list;
 * the entry in {@code positions} records its position and whether the
 * segment was quoted.
 */
  final public void IdentifierSegment(List<String> names, List<ParserPos> positions) throws ParseException {final String id;
    final ParserPos pos;
    final Span span;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      jj_consume_token(IDENTIFIER);
id = unquotedIdentifier();
            pos = getPos();
      break;
      }
    case QUOTED_IDENTIFIER:{
      jj_consume_token(QUOTED_IDENTIFIER);
id = SqlParserUtil.strip(getToken(0).image, DQ, DQ, DQDQ);
            pos = getPos().withQuoting(true);
      break;
      }
    case BACK_QUOTED_IDENTIFIER:{
      jj_consume_token(BACK_QUOTED_IDENTIFIER);
id = SqlParserUtil.strip(getToken(0).image, "`", "`", "``");
            pos = getPos().withQuoting(true);
      break;
      }
    case BRACKET_QUOTED_IDENTIFIER:{
      jj_consume_token(BRACKET_QUOTED_IDENTIFIER);
id = SqlParserUtil.strip(getToken(0).image, "[", "]", "]]");
            pos = getPos().withQuoting(true);
      break;
      }
    case UNICODE_QUOTED_IDENTIFIER:{
      jj_consume_token(UNICODE_QUOTED_IDENTIFIER);
span = span();
            String image = getToken(0).image;
            image = image.substring(image.indexOf('"'));
            image = SqlParserUtil.strip(image, DQ, DQ, DQDQ);
pos = span.end(this).withQuoting(true);
            Literal lit = Literal.createCharString(image, "UTF16", pos);
            id = (String)(lit.toValue());
      break;
      }
    case A:
    case ABSENT:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case APPLY:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CENTURY:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITIONAL:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATABASE:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DECADE:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DOW:
    case DOY:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case ENCODING:
    case EPOCH:
    case ERROR:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORMAT:
    case FORTRAN:
    case FOUND:
    case FRAC_SECOND:
    case G:
    case GENERAL:
    case GENERATED:
    case GEOMETRY:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IGNORE:
    case IMMEDIATE:
    case IMMEDIATELY:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISODOW:
    case ISOYEAR:
    case ISOLATION:
    case JAVA:
    case JSON:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MICROSECOND:
    case MILLISECOND:
    case MILLENNIUM:
    case MINVALUE:
    case MORE_:
    case MUMPS:
    case NAME:
    case NAMES:
    case NANOSECOND:
    case NESTING:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSING:
    case PASSTHROUGH:
    case PAST:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case QUARTER:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case REPLACE:
    case RESPECT:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case RETURNING:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALAR:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case SQL_BIGINT:
    case SQL_BINARY:
    case SQL_BIT:
    case SQL_BLOB:
    case SQL_BOOLEAN:
    case SQL_CHAR:
    case SQL_CLOB:
    case SQL_DATE:
    case SQL_DECIMAL:
    case SQL_DOUBLE:
    case SQL_FLOAT:
    case SQL_INTEGER:
    case SQL_INTERVAL_DAY:
    case SQL_INTERVAL_DAY_TO_HOUR:
    case SQL_INTERVAL_DAY_TO_MINUTE:
    case SQL_INTERVAL_DAY_TO_SECOND:
    case SQL_INTERVAL_HOUR:
    case SQL_INTERVAL_HOUR_TO_MINUTE:
    case SQL_INTERVAL_HOUR_TO_SECOND:
    case SQL_INTERVAL_MINUTE:
    case SQL_INTERVAL_MINUTE_TO_SECOND:
    case SQL_INTERVAL_MONTH:
    case SQL_INTERVAL_SECOND:
    case SQL_INTERVAL_YEAR:
    case SQL_INTERVAL_YEAR_TO_MONTH:
    case SQL_LONGVARBINARY:
    case SQL_LONGVARCHAR:
    case SQL_LONGVARNCHAR:
    case SQL_NCHAR:
    case SQL_NCLOB:
    case SQL_NUMERIC:
    case SQL_NVARCHAR:
    case SQL_REAL:
    case SQL_SMALLINT:
    case SQL_TIME:
    case SQL_TIMESTAMP:
    case SQL_TINYINT:
    case SQL_TSI_DAY:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_HOUR:
    case SQL_TSI_MICROSECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_SECOND:
    case SQL_TSI_WEEK:
    case SQL_TSI_YEAR:
    case SQL_VARBINARY:
    case SQL_VARCHAR:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNCONDITIONAL:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case UTF8:
    case UTF16:
    case UTF32:
    case VERSION:
    case VIEW:
    case WEEK:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:{
      id = NonReservedKeyWord();
pos = getPos();
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
names.add(id);
        if (positions != null) {
            positions.add(pos);
        }
}

/**
 * Parses a simple identifier as a String.
 */
  final public String Identifier() throws ParseException {final List<String> names = new ArrayList<String>();
    IdentifierSegment(names, null);
{if ("" != null) return names.get(0);}
    throw new Error("Missing return statement in function");
}

/**
 * Parses a simple identifier as an SqlIdentifier.
 */
  final public Identifier SimpleIdentifier() throws ParseException {final List<String> names = new ArrayList<String>();
    final List<ParserPos> positions = new ArrayList<ParserPos>();
    IdentifierSegment(names, positions);
{if ("" != null) return new Identifier(names, positions.get(0));}
    throw new Error("Missing return statement in function");
}

/**
 * Parses a comma-separated list of simple identifiers.
 */
  final public void SimpleIdentifierCommaList(List<Node> list) throws ParseException {Identifier id;
    id = SimpleIdentifier();
list.add(id);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_10;
      }
      jj_consume_token(COMMA);
      id = SimpleIdentifier();
list.add(id);
    }
}

/**
  * List of simple identifiers in parentheses. The position extends from the
  * open parenthesis to the close parenthesis.
  */
  final public Node ParenthesizedSimpleIdentifierList() throws ParseException {final Span s;
    final List<Node> list = new ArrayList<Node>();
    jj_consume_token(LPAREN);
s = span();
    SimpleIdentifierCommaList(list);
    jj_consume_token(RPAREN);
ParserPos pos = s.end(this);
            NodeList nodelist = new NodeList(list, pos);
            ParenthesizedNode node = new ParenthesizedNode(pos);
            node.setNode(nodelist);
        {if ("" != null) return node;}
    throw new Error("Missing return statement in function");
}

/**
 * Parses a compound identifier.
 */
  final public Identifier CompoundIdentifier() throws ParseException {final List<String> nameList = new ArrayList<String>();
    final List<ParserPos> posList = new ArrayList<ParserPos>();
    boolean star = false;
    IdentifierSegment(nameList, posList);
    label_11:
    while (true) {
      if (jj_2_9(2)) {
        ;
      } else {
        break label_11;
      }
      jj_consume_token(DOT);
      IdentifierSegment(nameList, posList);
    }
    if (jj_2_10(2)) {
      jj_consume_token(DOT);
      jj_consume_token(STAR);
star = true;
            nameList.add("");
            posList.add(getPos());
    } else {
      ;
    }
ParserPos pos = ParserPos.sum(posList);

        {if ("" != null) return new Identifier(nameList,  pos);}
    throw new Error("Missing return statement in function");
}

//TODO: real parse errors.
  final public int UnsignedIntLiteral() throws ParseException {Token t;
    t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
try {
            {if ("" != null) return Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw ex;}
        }
    throw new Error("Missing return statement in function");
}

  final public int IntLiteral() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER_LITERAL:
    case PLUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNSIGNED_INTEGER_LITERAL:{
        t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
        break;
        }
      case PLUS:{
        jj_consume_token(PLUS);
        t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
try {
            {if ("" != null) return Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw ex;}
        }
      break;
      }
    case MINUS:{
      jj_consume_token(MINUS);
      t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
try {
            {if ("" != null) return -Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw ex;}
        }
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/**
* Parse a nullable option, default is true.
*/
  final public boolean NullableOptDefaultTrue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NULL:{
      jj_consume_token(NULL);
{if ("" != null) return true;}
      break;
      }
    case NOT:{
      jj_consume_token(NOT);
      jj_consume_token(NULL);
{if ("" != null) return false;}
      break;
      }
    default:
      jj_la1[23] = jj_gen;
{if ("" != null) return true;}
    }
    throw new Error("Missing return statement in function");
}

/**
* Parse a nullable option, default is false.
*/
  final public boolean NullableOptDefaultFalse() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NULL:{
      jj_consume_token(NULL);
{if ("" != null) return true;}
      break;
      }
    case NOT:{
      jj_consume_token(NOT);
      jj_consume_token(NULL);
{if ("" != null) return false;}
      break;
      }
    default:
      jj_la1[24] = jj_gen;
{if ("" != null) return false;}
    }
    throw new Error("Missing return statement in function");
}

// Parse an optional data type precision, default is -1.
  final public int PrecisionOpt() throws ParseException {int precision = -1;
    if (jj_2_11(2)) {
      jj_consume_token(LPAREN);
      precision = UnsignedIntLiteral();
      jj_consume_token(RPAREN);
{if ("" != null) return precision;}
    } else {
{if ("" != null) return -1;}
    }
    throw new Error("Missing return statement in function");
}

/**
 * Parses a call to a named function (could be a builtin with regular
 * syntax, or else a UDF).
 *
 * <p>NOTE: every UDF has two names: an <em>invocation name</em> and a
 * <em>specific name</em>.  Normally, function calls are resolved via overload
 * resolution and invocation names.  The SPECIFIC prefix allows overload
 * resolution to be bypassed.  Note that usage of the SPECIFIC prefix in
 * queries is non-standard; it is used internally by Farrago, e.g. in stored
 * view definitions to permanently bind references to a particular function
 * after the overload resolution performed by view creation.
 *
 * <p>TODO jvs 25-Mar-2005:  Once we have SQL-Flagger support, flag SPECIFIC
 * as non-standard.
 */
  final public NamedFunction NamedFunctionCall() throws ParseException {final Identifier qualifiedName;
    final Span s;
    List<Node> args = new ArrayList<Node>();
    final NamedFunction call;
    Literal quantifier = null;
    NodeList orderList = null;
    final Span withinGroupSpan;
    qualifiedName = FunctionName();
s = span();
    if (jj_2_12(2)) {
      jj_consume_token(LPAREN);
      jj_consume_token(RPAREN);
args = Collections.emptyList();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        args = FunctionParameterList();
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
call = new NamedFunction(s.end(this),qualifiedName.toString(),args);
        {if ("" != null) return call;}
    throw new Error("Missing return statement in function");
}

/**
 * Parses the name of a function (either a compound identifier or
 * a reserved word which can be used as a function name).
 */
  final public Identifier FunctionName() throws ParseException {Identifier qualifiedName;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case A:
    case ABSENT:
    case ABSOLUTE:
    case ACTION:
    case ADA:
    case ADD:
    case ADMIN:
    case AFTER:
    case ALWAYS:
    case APPLY:
    case ASC:
    case ASSERTION:
    case ASSIGNMENT:
    case ATTRIBUTE:
    case ATTRIBUTES:
    case BEFORE:
    case BERNOULLI:
    case BREADTH:
    case C:
    case CASCADE:
    case CATALOG:
    case CATALOG_NAME:
    case CENTURY:
    case CHAIN:
    case CHARACTER_SET_CATALOG:
    case CHARACTER_SET_NAME:
    case CHARACTER_SET_SCHEMA:
    case CHARACTERISTICS:
    case CHARACTERS:
    case CLASS_ORIGIN:
    case COBOL:
    case COLLATION:
    case COLLATION_CATALOG:
    case COLLATION_NAME:
    case COLLATION_SCHEMA:
    case COLUMN_NAME:
    case COMMAND_FUNCTION:
    case COMMAND_FUNCTION_CODE:
    case COMMITTED:
    case CONDITIONAL:
    case CONDITION_NUMBER:
    case CONNECTION:
    case CONNECTION_NAME:
    case CONSTRAINT_CATALOG:
    case CONSTRAINT_NAME:
    case CONSTRAINT_SCHEMA:
    case CONSTRAINTS:
    case CONSTRUCTOR:
    case CONTINUE:
    case CURSOR_NAME:
    case DATA:
    case DATABASE:
    case DATETIME_INTERVAL_CODE:
    case DATETIME_INTERVAL_PRECISION:
    case DECADE:
    case DEFAULTS:
    case DEFERRABLE:
    case DEFERRED:
    case DEFINED:
    case DEFINER:
    case DEGREE:
    case DEPTH:
    case DERIVED:
    case DESC:
    case DESCRIPTION:
    case DESCRIPTOR:
    case DIAGNOSTICS:
    case DISPATCH:
    case DOMAIN:
    case DOW:
    case DOY:
    case DYNAMIC_FUNCTION:
    case DYNAMIC_FUNCTION_CODE:
    case ENCODING:
    case EPOCH:
    case ERROR:
    case EXCEPTION:
    case EXCLUDE:
    case EXCLUDING:
    case FINAL:
    case FIRST:
    case FOLLOWING:
    case FORMAT:
    case FORTRAN:
    case FOUND:
    case FRAC_SECOND:
    case G:
    case GENERAL:
    case GENERATED:
    case GEOMETRY:
    case GO:
    case GOTO:
    case GRANTED:
    case HIERARCHY:
    case IGNORE:
    case IMMEDIATE:
    case IMMEDIATELY:
    case IMPLEMENTATION:
    case INCLUDING:
    case INCREMENT:
    case INITIALLY:
    case INPUT:
    case INSTANCE:
    case INSTANTIABLE:
    case INVOKER:
    case ISODOW:
    case ISOYEAR:
    case ISOLATION:
    case JAVA:
    case JSON:
    case K:
    case KEY:
    case KEY_MEMBER:
    case KEY_TYPE:
    case LABEL:
    case LAST:
    case LENGTH:
    case LEVEL:
    case LIBRARY:
    case LOCATOR:
    case M:
    case MAP:
    case MATCHED:
    case MAXVALUE:
    case MESSAGE_LENGTH:
    case MESSAGE_OCTET_LENGTH:
    case MESSAGE_TEXT:
    case MICROSECOND:
    case MILLISECOND:
    case MILLENNIUM:
    case MINVALUE:
    case MORE_:
    case MUMPS:
    case NAME:
    case NAMES:
    case NANOSECOND:
    case NESTING:
    case NORMALIZED:
    case NULLABLE:
    case NULLS:
    case NUMBER:
    case OBJECT:
    case OCTETS:
    case OPTION:
    case OPTIONS:
    case ORDERING:
    case ORDINALITY:
    case OTHERS:
    case OUTPUT:
    case OVERRIDING:
    case PAD:
    case PARAMETER_MODE:
    case PARAMETER_NAME:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARAMETER_SPECIFIC_NAME:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PARTIAL:
    case PASCAL:
    case PASSING:
    case PASSTHROUGH:
    case PAST:
    case PATH:
    case PLACING:
    case PLAN:
    case PLI:
    case PRECEDING:
    case PRESERVE:
    case PRIOR:
    case PRIVILEGES:
    case PUBLIC:
    case QUARTER:
    case READ:
    case RELATIVE:
    case REPEATABLE:
    case REPLACE:
    case RESPECT:
    case RESTART:
    case RESTRICT:
    case RETURNED_CARDINALITY:
    case RETURNED_LENGTH:
    case RETURNED_OCTET_LENGTH:
    case RETURNED_SQLSTATE:
    case RETURNING:
    case ROLE:
    case ROUTINE:
    case ROUTINE_CATALOG:
    case ROUTINE_NAME:
    case ROUTINE_SCHEMA:
    case ROW_COUNT:
    case SCALAR:
    case SCALE:
    case SCHEMA:
    case SCHEMA_NAME:
    case SCOPE_CATALOGS:
    case SCOPE_NAME:
    case SCOPE_SCHEMA:
    case SECTION:
    case SECURITY:
    case SELF:
    case SEQUENCE:
    case SERIALIZABLE:
    case SERVER:
    case SERVER_NAME:
    case SESSION:
    case SETS:
    case SIMPLE:
    case SIZE:
    case SOURCE:
    case SPACE:
    case SPECIFIC_NAME:
    case SQL_BIGINT:
    case SQL_BINARY:
    case SQL_BIT:
    case SQL_BLOB:
    case SQL_BOOLEAN:
    case SQL_CHAR:
    case SQL_CLOB:
    case SQL_DATE:
    case SQL_DECIMAL:
    case SQL_DOUBLE:
    case SQL_FLOAT:
    case SQL_INTEGER:
    case SQL_INTERVAL_DAY:
    case SQL_INTERVAL_DAY_TO_HOUR:
    case SQL_INTERVAL_DAY_TO_MINUTE:
    case SQL_INTERVAL_DAY_TO_SECOND:
    case SQL_INTERVAL_HOUR:
    case SQL_INTERVAL_HOUR_TO_MINUTE:
    case SQL_INTERVAL_HOUR_TO_SECOND:
    case SQL_INTERVAL_MINUTE:
    case SQL_INTERVAL_MINUTE_TO_SECOND:
    case SQL_INTERVAL_MONTH:
    case SQL_INTERVAL_SECOND:
    case SQL_INTERVAL_YEAR:
    case SQL_INTERVAL_YEAR_TO_MONTH:
    case SQL_LONGVARBINARY:
    case SQL_LONGVARCHAR:
    case SQL_LONGVARNCHAR:
    case SQL_NCHAR:
    case SQL_NCLOB:
    case SQL_NUMERIC:
    case SQL_NVARCHAR:
    case SQL_REAL:
    case SQL_SMALLINT:
    case SQL_TIME:
    case SQL_TIMESTAMP:
    case SQL_TINYINT:
    case SQL_TSI_DAY:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_HOUR:
    case SQL_TSI_MICROSECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_MONTH:
    case SQL_TSI_QUARTER:
    case SQL_TSI_SECOND:
    case SQL_TSI_WEEK:
    case SQL_TSI_YEAR:
    case SQL_VARBINARY:
    case SQL_VARCHAR:
    case STATE:
    case STATEMENT:
    case STRUCTURE:
    case STYLE:
    case SUBCLASS_ORIGIN:
    case SUBSTITUTE:
    case TABLE_NAME:
    case TEMPORARY:
    case TIES:
    case TIMESTAMPADD:
    case TIMESTAMPDIFF:
    case TOP_LEVEL_COUNT:
    case TRANSACTION:
    case TRANSACTIONS_ACTIVE:
    case TRANSACTIONS_COMMITTED:
    case TRANSACTIONS_ROLLED_BACK:
    case TRANSFORM:
    case TRANSFORMS:
    case TRIGGER_CATALOG:
    case TRIGGER_NAME:
    case TRIGGER_SCHEMA:
    case TYPE:
    case UNBOUNDED:
    case UNCOMMITTED:
    case UNCONDITIONAL:
    case UNDER:
    case UNNAMED:
    case USAGE:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_CODE:
    case USER_DEFINED_TYPE_NAME:
    case USER_DEFINED_TYPE_SCHEMA:
    case UTF8:
    case UTF16:
    case UTF32:
    case VERSION:
    case VIEW:
    case WEEK:
    case WORK:
    case WRAPPER:
    case WRITE:
    case XML:
    case ZONE:
    case BRACKET_QUOTED_IDENTIFIER:
    case QUOTED_IDENTIFIER:
    case BACK_QUOTED_IDENTIFIER:
    case IDENTIFIER:
    case UNICODE_QUOTED_IDENTIFIER:{
      qualifiedName = CompoundIdentifier();
      break;
      }
    case ABS:
    case AVG:
    case CARDINALITY:
    case CEILING:
    case CHAR_LENGTH:
    case CHARACTER_LENGTH:
    case COALESCE:
    case COLLECT:
    case COUNT:
    case COVAR_POP:
    case COVAR_SAMP:
    case CUME_DIST:
    case CURRENT_DATE:
    case CURRENT_TIME:
    case CURRENT_TIMESTAMP:
    case DENSE_RANK:
    case ELEMENT:
    case EXP:
    case FIRST_VALUE:
    case FLOOR:
    case FUSION:
    case GROUPING:
    case HOUR:
    case LAG:
    case LAST_VALUE:
    case LEAD:
    case LEFT:
    case LN:
    case LOCALTIME:
    case LOCALTIMESTAMP:
    case LOWER:
    case MAX:
    case MIN:
    case MINUTE:
    case MOD:
    case MONTH:
    case NTH_VALUE:
    case NTILE:
    case NULLIF:
    case OCTET_LENGTH:
    case PERCENT_RANK:
    case POWER:
    case RANK:
    case REGR_COUNT:
    case REGR_SXX:
    case REGR_SYY:
    case RIGHT:
    case ROW_NUMBER:
    case SECOND:
    case SQRT:
    case STDDEV_POP:
    case STDDEV_SAMP:
    case SUM:
    case TRUNCATE:
    case UPPER:
    case USER:
    case VAR_POP:
    case VAR_SAMP:
    case YEAR:{
      qualifiedName = ReservedFunctionName();
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return qualifiedName;}
    throw new Error("Missing return statement in function");
}

/**
 * Parses a reserved word which is used as the name of a function.
 */
  final public Identifier ReservedFunctionName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ABS:{
      jj_consume_token(ABS);
      break;
      }
    case AVG:{
      jj_consume_token(AVG);
      break;
      }
    case CARDINALITY:{
      jj_consume_token(CARDINALITY);
      break;
      }
    case CEILING:{
      jj_consume_token(CEILING);
      break;
      }
    case CHAR_LENGTH:{
      jj_consume_token(CHAR_LENGTH);
      break;
      }
    case CHARACTER_LENGTH:{
      jj_consume_token(CHARACTER_LENGTH);
      break;
      }
    case COALESCE:{
      jj_consume_token(COALESCE);
      break;
      }
    case COLLECT:{
      jj_consume_token(COLLECT);
      break;
      }
    case COVAR_POP:{
      jj_consume_token(COVAR_POP);
      break;
      }
    case COVAR_SAMP:{
      jj_consume_token(COVAR_SAMP);
      break;
      }
    case CUME_DIST:{
      jj_consume_token(CUME_DIST);
      break;
      }
    case COUNT:{
      jj_consume_token(COUNT);
      break;
      }
    case CURRENT_DATE:{
      jj_consume_token(CURRENT_DATE);
      break;
      }
    case CURRENT_TIME:{
      jj_consume_token(CURRENT_TIME);
      break;
      }
    case CURRENT_TIMESTAMP:{
      jj_consume_token(CURRENT_TIMESTAMP);
      break;
      }
    case DENSE_RANK:{
      jj_consume_token(DENSE_RANK);
      break;
      }
    case ELEMENT:{
      jj_consume_token(ELEMENT);
      break;
      }
    case EXP:{
      jj_consume_token(EXP);
      break;
      }
    case FIRST_VALUE:{
      jj_consume_token(FIRST_VALUE);
      break;
      }
    case FLOOR:{
      jj_consume_token(FLOOR);
      break;
      }
    case FUSION:{
      jj_consume_token(FUSION);
      break;
      }
    case GROUPING:{
      jj_consume_token(GROUPING);
      break;
      }
    case HOUR:{
      jj_consume_token(HOUR);
      break;
      }
    case LAG:{
      jj_consume_token(LAG);
      break;
      }
    case LEAD:{
      jj_consume_token(LEAD);
      break;
      }
    case LEFT:{
      jj_consume_token(LEFT);
      break;
      }
    case LAST_VALUE:{
      jj_consume_token(LAST_VALUE);
      break;
      }
    case LN:{
      jj_consume_token(LN);
      break;
      }
    case LOCALTIME:{
      jj_consume_token(LOCALTIME);
      break;
      }
    case LOCALTIMESTAMP:{
      jj_consume_token(LOCALTIMESTAMP);
      break;
      }
    case LOWER:{
      jj_consume_token(LOWER);
      break;
      }
    case MAX:{
      jj_consume_token(MAX);
      break;
      }
    case MIN:{
      jj_consume_token(MIN);
      break;
      }
    case MINUTE:{
      jj_consume_token(MINUTE);
      break;
      }
    case MOD:{
      jj_consume_token(MOD);
      break;
      }
    case MONTH:{
      jj_consume_token(MONTH);
      break;
      }
    case NTH_VALUE:{
      jj_consume_token(NTH_VALUE);
      break;
      }
    case NTILE:{
      jj_consume_token(NTILE);
      break;
      }
    case NULLIF:{
      jj_consume_token(NULLIF);
      break;
      }
    case OCTET_LENGTH:{
      jj_consume_token(OCTET_LENGTH);
      break;
      }
    case PERCENT_RANK:{
      jj_consume_token(PERCENT_RANK);
      break;
      }
    case POWER:{
      jj_consume_token(POWER);
      break;
      }
    case RANK:{
      jj_consume_token(RANK);
      break;
      }
    case REGR_COUNT:{
      jj_consume_token(REGR_COUNT);
      break;
      }
    case REGR_SXX:{
      jj_consume_token(REGR_SXX);
      break;
      }
    case REGR_SYY:{
      jj_consume_token(REGR_SYY);
      break;
      }
    case RIGHT:{
      jj_consume_token(RIGHT);
      break;
      }
    case ROW_NUMBER:{
      jj_consume_token(ROW_NUMBER);
      break;
      }
    case SECOND:{
      jj_consume_token(SECOND);
      break;
      }
    case SQRT:{
      jj_consume_token(SQRT);
      break;
      }
    case STDDEV_POP:{
      jj_consume_token(STDDEV_POP);
      break;
      }
    case STDDEV_SAMP:{
      jj_consume_token(STDDEV_SAMP);
      break;
      }
    case SUM:{
      jj_consume_token(SUM);
      break;
      }
    case UPPER:{
      jj_consume_token(UPPER);
      break;
      }
    case TRUNCATE:{
      jj_consume_token(TRUNCATE);
      break;
      }
    case USER:{
      jj_consume_token(USER);
      break;
      }
    case VAR_POP:{
      jj_consume_token(VAR_POP);
      break;
      }
    case VAR_SAMP:{
      jj_consume_token(VAR_SAMP);
      break;
      }
    case YEAR:{
      jj_consume_token(YEAR);
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new Identifier(Lists.newArrayList(unquotedIdentifier()), getPos());}
    throw new Error("Missing return statement in function");
}

  final public Identifier ContextVariable() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CURRENT_CATALOG:{
      jj_consume_token(CURRENT_CATALOG);
      break;
      }
    case CURRENT_DATE:{
      jj_consume_token(CURRENT_DATE);
      break;
      }
    case CURRENT_DEFAULT_TRANSFORM_GROUP:{
      jj_consume_token(CURRENT_DEFAULT_TRANSFORM_GROUP);
      break;
      }
    case CURRENT_PATH:{
      jj_consume_token(CURRENT_PATH);
      break;
      }
    case CURRENT_ROLE:{
      jj_consume_token(CURRENT_ROLE);
      break;
      }
    case CURRENT_SCHEMA:{
      jj_consume_token(CURRENT_SCHEMA);
      break;
      }
    case CURRENT_TIME:{
      jj_consume_token(CURRENT_TIME);
      break;
      }
    case CURRENT_TIMESTAMP:{
      jj_consume_token(CURRENT_TIMESTAMP);
      break;
      }
    case CURRENT_USER:{
      jj_consume_token(CURRENT_USER);
      break;
      }
    case LOCALTIME:{
      jj_consume_token(LOCALTIME);
      break;
      }
    case LOCALTIMESTAMP:{
      jj_consume_token(LOCALTIMESTAMP);
      break;
      }
    case SESSION_USER:{
      jj_consume_token(SESSION_USER);
      break;
      }
    case SYSTEM_USER:{
      jj_consume_token(SYSTEM_USER);
      break;
      }
    case USER:{
      jj_consume_token(USER);
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new Identifier(Lists.newArrayList(unquotedIdentifier()), getPos());}
    throw new Error("Missing return statement in function");
}

/**
 * Parses a binary row operator like AND.
 */
  final public BinaryOperator BinaryRowOperator() throws ParseException {BinaryOperator op;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQ:{
      jj_consume_token(EQ);
{if ("" != null) return StdOperatorTable.EQUALS;}
      break;
      }
    case GT:{
      jj_consume_token(GT);
{if ("" != null) return StdOperatorTable.GREATER_THAN;}
      break;
      }
    case LT:{
      jj_consume_token(LT);
{if ("" != null) return StdOperatorTable.LESS_THAN;}
      break;
      }
    case LE:{
      jj_consume_token(LE);
{if ("" != null) return StdOperatorTable.LESS_THAN_OR_EQUAL;}
      break;
      }
    case GE:{
      jj_consume_token(GE);
{if ("" != null) return StdOperatorTable.GREATER_THAN_OR_EQUAL;}
      break;
      }
    case NE:{
      jj_consume_token(NE);
{if ("" != null) return StdOperatorTable.NOT_EQUALS;}
      break;
      }
    case NE2:{
      jj_consume_token(NE2);
{if ("" != null) return StdOperatorTable.NOT_EQUALS;}
      break;
      }
    case PLUS:{
      jj_consume_token(PLUS);
{if ("" != null) return StdOperatorTable.PLUS;}
      break;
      }
    case MINUS:{
      jj_consume_token(MINUS);
{if ("" != null) return StdOperatorTable.MINUS;}
      break;
      }
    case STAR:{
      jj_consume_token(STAR);
{if ("" != null) return StdOperatorTable.MULTIPLY;}
      break;
      }
    case SLASH:{
      jj_consume_token(SLASH);
{if ("" != null) return StdOperatorTable.DIVIDE;}
      break;
      }
    case PERCENT_REMAINDER:{
      jj_consume_token(PERCENT_REMAINDER);
{if ("" != null) return StdOperatorTable.MOD;}
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/**
 * Parses a prefix row operator like NOT.
 */
  final public SqlParserUtil.ToTreeListItem PrefixRowOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PLUS:{
      jj_consume_token(PLUS);
      //("+",SqlKind.PLUS,40,true);;
{if ("" != null) return new SqlParserUtil.ToTreeListItem( new PrefixOperator("+",SqlKind.PLUS,40,true),getPos());}
      break;
      }
    case MINUS:{
      jj_consume_token(MINUS);
{if ("" != null) return new SqlParserUtil.ToTreeListItem(new PrefixOperator("-",SqlKind.MINUS,40,true),getPos());}
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  final public String NonReservedKeyWord() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case A:
    case ACTION:
    case ADMIN:
    case APPLY:
    case ASSIGNMENT:
    case BEFORE:
    case C:
    case CATALOG_NAME:
    case CHARACTER_SET_CATALOG:
    case CHARACTERISTICS:
    case COBOL:
    case COLLATION_NAME:
    case COMMAND_FUNCTION:
    case CONDITION_NUMBER:
    case CONNECTION_NAME:
    case CONSTRAINT_SCHEMA:
    case CONTINUE:
    case DATABASE:
    case DECADE:
    case DEFERRED:
    case DEGREE:
    case DESC:
    case DIAGNOSTICS:
    case DOW:
    case DYNAMIC_FUNCTION_CODE:
    case ERROR:
    case EXCLUDING:
    case FOLLOWING:
    case FOUND:
    case GENERAL:
    case GO:
    case HIERARCHY:
    case IMMEDIATELY:
    case INCREMENT:
    case INSTANCE:
    case ISODOW:
    case JAVA:
    case KEY:
    case LABEL:
    case LEVEL:
    case M:
    case MAXVALUE:
    case MESSAGE_OCTET_LENGTH:
    case MILLENNIUM:
    case MUMPS:
    case NANOSECOND:
    case NULLABLE:
    case OBJECT:
    case OPTIONS:
    case OTHERS:
    case PAD:
    case PARAMETER_ORDINAL_POSITION:
    case PARAMETER_SPECIFIC_SCHEMA:
    case PASSING:
    case PATH:
    case PLI:
    case PRIOR:
    case QUARTER:
    case REPEATABLE:
    case RESTART:
    case RETURNED_LENGTH:
    case RETURNING:
    case ROUTINE_CATALOG:
    case ROW_COUNT:
    case SCHEMA:
    case SCOPE_NAME:
    case SECURITY:
    case SERIALIZABLE:
    case SESSION:
    case SIZE:
    case SPECIFIC_NAME:
    case SQL_BIT:
    case SQL_CHAR:
    case SQL_DECIMAL:
    case SQL_INTEGER:
    case SQL_INTERVAL_DAY_TO_MINUTE:
    case SQL_INTERVAL_HOUR_TO_MINUTE:
    case SQL_INTERVAL_MINUTE_TO_SECOND:
    case SQL_INTERVAL_YEAR:
    case SQL_LONGVARNCHAR:
    case SQL_NCLOB:
    case SQL_REAL:
    case SQL_TIMESTAMP:
    case SQL_TSI_FRAC_SECOND:
    case SQL_TSI_MINUTE:
    case SQL_TSI_SECOND:
    case SQL_VARBINARY:
    case STATEMENT:
    case SUBCLASS_ORIGIN:
    case TEMPORARY:
    case TIMESTAMPDIFF:
    case TRANSACTIONS_ACTIVE:
    case TRANSFORM:
    case TRIGGER_NAME:
    case UNBOUNDED:
    case UNDER:
    case USER_DEFINED_TYPE_CATALOG:
    case USER_DEFINED_TYPE_SCHEMA:
    case UTF32:
    case WEEK:
    case WRITE:{
      NonReservedKeyWord0of3();
      break;
      }
    case ABSENT:
    case ADA:
    case AFTER:
    case ASC:
    case ATTRIBUTE:
    case BERNOULLI:
    case CASCADE:
    case CENTURY:
    case CHARACTER_SET_NAME:
    case CHARACTERS:
    case COLLATION:
    case COLLATION_SCHEMA:
    case COMMAND_FUNCTION_CODE:
    case CONDITIONAL:
    case CONSTRAINT_CATALOG:
    case CONSTRAINTS:
    case CURSOR_NAME:
    case DATETIME_INTERVAL_CODE:
    case DEFAULTS:
    case DEFINED:
    case DEPTH:
    case DESCRIPTION:
    case DISPATCH:
    case DOY:
    case ENCODING:
    case EXCEPTION:
    case FINAL:
    case FORMAT:
    case FRAC_SECOND:
    case GENERATED:
    case GOTO:
    case IGNORE:
    case IMPLEMENTATION:
    case INITIALLY:
    case INSTANTIABLE:
    case ISOYEAR:
    case JSON:
    case KEY_MEMBER:
    case LAST:
    case LIBRARY:
    case MAP:
    case MESSAGE_TEXT:
    case MICROSECOND:
    case MINVALUE:
    case NAME:
    case NESTING:
    case NULLS:
    case OCTETS:
    case ORDERING:
    case OUTPUT:
    case PARAMETER_MODE:
    case PARAMETER_SPECIFIC_CATALOG:
    case PARTIAL:
    case PASSTHROUGH:
    case PLACING:
    case PRECEDING:
    case PRIVILEGES:
    case READ:
    case REPLACE:
    case RESTRICT:
    case RETURNED_OCTET_LENGTH:
    case ROLE:
    case ROUTINE_NAME:
    case SCALAR:
    case SCHEMA_NAME:
    case SCOPE_SCHEMA:
    case SELF:
    case SERVER:
    case SETS:
    case SOURCE:
    case SQL_BIGINT:
    case SQL_BLOB:
    case SQL_CLOB:
    case SQL_DOUBLE:
    case SQL_INTERVAL_DAY:
    case SQL_INTERVAL_DAY_TO_SECOND:
    case SQL_INTERVAL_HOUR_TO_SECOND:
    case SQL_INTERVAL_MONTH:
    case SQL_INTERVAL_YEAR_TO_MONTH:
    case SQL_LONGVARCHAR:
    case SQL_NUMERIC:
    case SQL_SMALLINT:
    case SQL_TINYINT:
    case SQL_TSI_HOUR:
    case SQL_TSI_MONTH:
    case SQL_TSI_WEEK:
    case SQL_VARCHAR:
    case STRUCTURE:
    case SUBSTITUTE:
    case TIES:
    case TOP_LEVEL_COUNT:
    case TRANSACTIONS_COMMITTED:
    case TRANSFORMS:
    case TRIGGER_SCHEMA:
    case UNCOMMITTED:
    case UNNAMED:
    case USER_DEFINED_TYPE_CODE:
    case UTF8:
    case VERSION:
    case WRAPPER:
    case XML:{
      NonReservedKeyWord1of3();
      break;
      }
    case ABSOLUTE:
    case ADD:
    case ALWAYS:
    case ASSERTION:
    case ATTRIBUTES:
    case BREADTH:
    case CATALOG:
    case CHAIN:
    case CHARACTER_SET_SCHEMA:
    case CLASS_ORIGIN:
    case COLLATION_CATALOG:
    case COLUMN_NAME:
    case COMMITTED:
    case CONNECTION:
    case CONSTRAINT_NAME:
    case CONSTRUCTOR:
    case DATA:
    case DATETIME_INTERVAL_PRECISION:
    case DEFERRABLE:
    case DEFINER:
    case DERIVED:
    case DESCRIPTOR:
    case DOMAIN:
    case DYNAMIC_FUNCTION:
    case EPOCH:
    case EXCLUDE:
    case FIRST:
    case FORTRAN:
    case G:
    case GEOMETRY:
    case GRANTED:
    case IMMEDIATE:
    case INCLUDING:
    case INPUT:
    case INVOKER:
    case ISOLATION:
    case K:
    case KEY_TYPE:
    case LENGTH:
    case LOCATOR:
    case MATCHED:
    case MESSAGE_LENGTH:
    case MILLISECOND:
    case MORE_:
    case NAMES:
    case NORMALIZED:
    case NUMBER:
    case OPTION:
    case ORDINALITY:
    case OVERRIDING:
    case PARAMETER_NAME:
    case PARAMETER_SPECIFIC_NAME:
    case PASCAL:
    case PAST:
    case PLAN:
    case PRESERVE:
    case PUBLIC:
    case RELATIVE:
    case RESPECT:
    case RETURNED_CARDINALITY:
    case RETURNED_SQLSTATE:
    case ROUTINE:
    case ROUTINE_SCHEMA:
    case SCALE:
    case SCOPE_CATALOGS:
    case SECTION:
    case SEQUENCE:
    case SERVER_NAME:
    case SIMPLE:
    case SPACE:
    case SQL_BINARY:
    case SQL_BOOLEAN:
    case SQL_DATE:
    case SQL_FLOAT:
    case SQL_INTERVAL_DAY_TO_HOUR:
    case SQL_INTERVAL_HOUR:
    case SQL_INTERVAL_MINUTE:
    case SQL_INTERVAL_SECOND:
    case SQL_LONGVARBINARY:
    case SQL_NCHAR:
    case SQL_NVARCHAR:
    case SQL_TIME:
    case SQL_TSI_DAY:
    case SQL_TSI_MICROSECOND:
    case SQL_TSI_QUARTER:
    case SQL_TSI_YEAR:
    case STATE:
    case STYLE:
    case TABLE_NAME:
    case TIMESTAMPADD:
    case TRANSACTION:
    case TRANSACTIONS_ROLLED_BACK:
    case TRIGGER_CATALOG:
    case TYPE:
    case UNCONDITIONAL:
    case USAGE:
    case USER_DEFINED_TYPE_NAME:
    case UTF16:
    case VIEW:
    case WORK:
    case ZONE:{
      NonReservedKeyWord2of3();
      break;
      }
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return unquotedIdentifier();}
    throw new Error("Missing return statement in function");
}

/** @see #NonReservedKeyWord */
  final public void NonReservedKeyWord0of3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case A:{
      jj_consume_token(A);
      break;
      }
    case ACTION:{
      jj_consume_token(ACTION);
      break;
      }
    case ADMIN:{
      jj_consume_token(ADMIN);
      break;
      }
    case APPLY:{
      jj_consume_token(APPLY);
      break;
      }
    case ASSIGNMENT:{
      jj_consume_token(ASSIGNMENT);
      break;
      }
    case BEFORE:{
      jj_consume_token(BEFORE);
      break;
      }
    case C:{
      jj_consume_token(C);
      break;
      }
    case CATALOG_NAME:{
      jj_consume_token(CATALOG_NAME);
      break;
      }
    case CHARACTER_SET_CATALOG:{
      jj_consume_token(CHARACTER_SET_CATALOG);
      break;
      }
    case CHARACTERISTICS:{
      jj_consume_token(CHARACTERISTICS);
      break;
      }
    case COBOL:{
      jj_consume_token(COBOL);
      break;
      }
    case COLLATION_NAME:{
      jj_consume_token(COLLATION_NAME);
      break;
      }
    case COMMAND_FUNCTION:{
      jj_consume_token(COMMAND_FUNCTION);
      break;
      }
    case CONDITION_NUMBER:{
      jj_consume_token(CONDITION_NUMBER);
      break;
      }
    case CONNECTION_NAME:{
      jj_consume_token(CONNECTION_NAME);
      break;
      }
    case CONSTRAINT_SCHEMA:{
      jj_consume_token(CONSTRAINT_SCHEMA);
      break;
      }
    case CONTINUE:{
      jj_consume_token(CONTINUE);
      break;
      }
    case DATABASE:{
      jj_consume_token(DATABASE);
      break;
      }
    case DECADE:{
      jj_consume_token(DECADE);
      break;
      }
    case DEFERRED:{
      jj_consume_token(DEFERRED);
      break;
      }
    case DEGREE:{
      jj_consume_token(DEGREE);
      break;
      }
    case DESC:{
      jj_consume_token(DESC);
      break;
      }
    case DIAGNOSTICS:{
      jj_consume_token(DIAGNOSTICS);
      break;
      }
    case DOW:{
      jj_consume_token(DOW);
      break;
      }
    case DYNAMIC_FUNCTION_CODE:{
      jj_consume_token(DYNAMIC_FUNCTION_CODE);
      break;
      }
    case ERROR:{
      jj_consume_token(ERROR);
      break;
      }
    case EXCLUDING:{
      jj_consume_token(EXCLUDING);
      break;
      }
    case FOLLOWING:{
      jj_consume_token(FOLLOWING);
      break;
      }
    case FOUND:{
      jj_consume_token(FOUND);
      break;
      }
    case GENERAL:{
      jj_consume_token(GENERAL);
      break;
      }
    case GO:{
      jj_consume_token(GO);
      break;
      }
    case HIERARCHY:{
      jj_consume_token(HIERARCHY);
      break;
      }
    case IMMEDIATELY:{
      jj_consume_token(IMMEDIATELY);
      break;
      }
    case INCREMENT:{
      jj_consume_token(INCREMENT);
      break;
      }
    case INSTANCE:{
      jj_consume_token(INSTANCE);
      break;
      }
    case ISODOW:{
      jj_consume_token(ISODOW);
      break;
      }
    case JAVA:{
      jj_consume_token(JAVA);
      break;
      }
    case KEY:{
      jj_consume_token(KEY);
      break;
      }
    case LABEL:{
      jj_consume_token(LABEL);
      break;
      }
    case LEVEL:{
      jj_consume_token(LEVEL);
      break;
      }
    case M:{
      jj_consume_token(M);
      break;
      }
    case MAXVALUE:{
      jj_consume_token(MAXVALUE);
      break;
      }
    case MESSAGE_OCTET_LENGTH:{
      jj_consume_token(MESSAGE_OCTET_LENGTH);
      break;
      }
    case MILLENNIUM:{
      jj_consume_token(MILLENNIUM);
      break;
      }
    case MUMPS:{
      jj_consume_token(MUMPS);
      break;
      }
    case NANOSECOND:{
      jj_consume_token(NANOSECOND);
      break;
      }
    case NULLABLE:{
      jj_consume_token(NULLABLE);
      break;
      }
    case OBJECT:{
      jj_consume_token(OBJECT);
      break;
      }
    case OPTIONS:{
      jj_consume_token(OPTIONS);
      break;
      }
    case OTHERS:{
      jj_consume_token(OTHERS);
      break;
      }
    case PAD:{
      jj_consume_token(PAD);
      break;
      }
    case PARAMETER_ORDINAL_POSITION:{
      jj_consume_token(PARAMETER_ORDINAL_POSITION);
      break;
      }
    case PARAMETER_SPECIFIC_SCHEMA:{
      jj_consume_token(PARAMETER_SPECIFIC_SCHEMA);
      break;
      }
    case PASSING:{
      jj_consume_token(PASSING);
      break;
      }
    case PATH:{
      jj_consume_token(PATH);
      break;
      }
    case PLI:{
      jj_consume_token(PLI);
      break;
      }
    case PRIOR:{
      jj_consume_token(PRIOR);
      break;
      }
    case QUARTER:{
      jj_consume_token(QUARTER);
      break;
      }
    case REPEATABLE:{
      jj_consume_token(REPEATABLE);
      break;
      }
    case RESTART:{
      jj_consume_token(RESTART);
      break;
      }
    case RETURNED_LENGTH:{
      jj_consume_token(RETURNED_LENGTH);
      break;
      }
    case RETURNING:{
      jj_consume_token(RETURNING);
      break;
      }
    case ROUTINE_CATALOG:{
      jj_consume_token(ROUTINE_CATALOG);
      break;
      }
    case ROW_COUNT:{
      jj_consume_token(ROW_COUNT);
      break;
      }
    case SCHEMA:{
      jj_consume_token(SCHEMA);
      break;
      }
    case SCOPE_NAME:{
      jj_consume_token(SCOPE_NAME);
      break;
      }
    case SECURITY:{
      jj_consume_token(SECURITY);
      break;
      }
    case SERIALIZABLE:{
      jj_consume_token(SERIALIZABLE);
      break;
      }
    case SESSION:{
      jj_consume_token(SESSION);
      break;
      }
    case SIZE:{
      jj_consume_token(SIZE);
      break;
      }
    case SPECIFIC_NAME:{
      jj_consume_token(SPECIFIC_NAME);
      break;
      }
    case SQL_BIT:{
      jj_consume_token(SQL_BIT);
      break;
      }
    case SQL_CHAR:{
      jj_consume_token(SQL_CHAR);
      break;
      }
    case SQL_DECIMAL:{
      jj_consume_token(SQL_DECIMAL);
      break;
      }
    case SQL_INTEGER:{
      jj_consume_token(SQL_INTEGER);
      break;
      }
    case SQL_INTERVAL_DAY_TO_MINUTE:{
      jj_consume_token(SQL_INTERVAL_DAY_TO_MINUTE);
      break;
      }
    case SQL_INTERVAL_HOUR_TO_MINUTE:{
      jj_consume_token(SQL_INTERVAL_HOUR_TO_MINUTE);
      break;
      }
    case SQL_INTERVAL_MINUTE_TO_SECOND:{
      jj_consume_token(SQL_INTERVAL_MINUTE_TO_SECOND);
      break;
      }
    case SQL_INTERVAL_YEAR:{
      jj_consume_token(SQL_INTERVAL_YEAR);
      break;
      }
    case SQL_LONGVARNCHAR:{
      jj_consume_token(SQL_LONGVARNCHAR);
      break;
      }
    case SQL_NCLOB:{
      jj_consume_token(SQL_NCLOB);
      break;
      }
    case SQL_REAL:{
      jj_consume_token(SQL_REAL);
      break;
      }
    case SQL_TIMESTAMP:{
      jj_consume_token(SQL_TIMESTAMP);
      break;
      }
    case SQL_TSI_FRAC_SECOND:{
      jj_consume_token(SQL_TSI_FRAC_SECOND);
      break;
      }
    case SQL_TSI_MINUTE:{
      jj_consume_token(SQL_TSI_MINUTE);
      break;
      }
    case SQL_TSI_SECOND:{
      jj_consume_token(SQL_TSI_SECOND);
      break;
      }
    case SQL_VARBINARY:{
      jj_consume_token(SQL_VARBINARY);
      break;
      }
    case STATEMENT:{
      jj_consume_token(STATEMENT);
      break;
      }
    case SUBCLASS_ORIGIN:{
      jj_consume_token(SUBCLASS_ORIGIN);
      break;
      }
    case TEMPORARY:{
      jj_consume_token(TEMPORARY);
      break;
      }
    case TIMESTAMPDIFF:{
      jj_consume_token(TIMESTAMPDIFF);
      break;
      }
    case TRANSACTIONS_ACTIVE:{
      jj_consume_token(TRANSACTIONS_ACTIVE);
      break;
      }
    case TRANSFORM:{
      jj_consume_token(TRANSFORM);
      break;
      }
    case TRIGGER_NAME:{
      jj_consume_token(TRIGGER_NAME);
      break;
      }
    case UNBOUNDED:{
      jj_consume_token(UNBOUNDED);
      break;
      }
    case UNDER:{
      jj_consume_token(UNDER);
      break;
      }
    case USER_DEFINED_TYPE_CATALOG:{
      jj_consume_token(USER_DEFINED_TYPE_CATALOG);
      break;
      }
    case USER_DEFINED_TYPE_SCHEMA:{
      jj_consume_token(USER_DEFINED_TYPE_SCHEMA);
      break;
      }
    case UTF32:{
      jj_consume_token(UTF32);
      break;
      }
    case WEEK:{
      jj_consume_token(WEEK);
      break;
      }
    case WRITE:{
      jj_consume_token(WRITE);
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

/** @see #NonReservedKeyWord */
  final public void NonReservedKeyWord1of3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ABSENT:{
      jj_consume_token(ABSENT);
      break;
      }
    case ADA:{
      jj_consume_token(ADA);
      break;
      }
    case AFTER:{
      jj_consume_token(AFTER);
      break;
      }
    case ASC:{
      jj_consume_token(ASC);
      break;
      }
    case ATTRIBUTE:{
      jj_consume_token(ATTRIBUTE);
      break;
      }
    case BERNOULLI:{
      jj_consume_token(BERNOULLI);
      break;
      }
    case CASCADE:{
      jj_consume_token(CASCADE);
      break;
      }
    case CENTURY:{
      jj_consume_token(CENTURY);
      break;
      }
    case CHARACTER_SET_NAME:{
      jj_consume_token(CHARACTER_SET_NAME);
      break;
      }
    case CHARACTERS:{
      jj_consume_token(CHARACTERS);
      break;
      }
    case COLLATION:{
      jj_consume_token(COLLATION);
      break;
      }
    case COLLATION_SCHEMA:{
      jj_consume_token(COLLATION_SCHEMA);
      break;
      }
    case COMMAND_FUNCTION_CODE:{
      jj_consume_token(COMMAND_FUNCTION_CODE);
      break;
      }
    case CONDITIONAL:{
      jj_consume_token(CONDITIONAL);
      break;
      }
    case CONSTRAINT_CATALOG:{
      jj_consume_token(CONSTRAINT_CATALOG);
      break;
      }
    case CONSTRAINTS:{
      jj_consume_token(CONSTRAINTS);
      break;
      }
    case CURSOR_NAME:{
      jj_consume_token(CURSOR_NAME);
      break;
      }
    case DATETIME_INTERVAL_CODE:{
      jj_consume_token(DATETIME_INTERVAL_CODE);
      break;
      }
    case DEFAULTS:{
      jj_consume_token(DEFAULTS);
      break;
      }
    case DEFINED:{
      jj_consume_token(DEFINED);
      break;
      }
    case DEPTH:{
      jj_consume_token(DEPTH);
      break;
      }
    case DESCRIPTION:{
      jj_consume_token(DESCRIPTION);
      break;
      }
    case DISPATCH:{
      jj_consume_token(DISPATCH);
      break;
      }
    case DOY:{
      jj_consume_token(DOY);
      break;
      }
    case ENCODING:{
      jj_consume_token(ENCODING);
      break;
      }
    case EXCEPTION:{
      jj_consume_token(EXCEPTION);
      break;
      }
    case FINAL:{
      jj_consume_token(FINAL);
      break;
      }
    case FORMAT:{
      jj_consume_token(FORMAT);
      break;
      }
    case FRAC_SECOND:{
      jj_consume_token(FRAC_SECOND);
      break;
      }
    case GENERATED:{
      jj_consume_token(GENERATED);
      break;
      }
    case GOTO:{
      jj_consume_token(GOTO);
      break;
      }
    case IGNORE:{
      jj_consume_token(IGNORE);
      break;
      }
    case IMPLEMENTATION:{
      jj_consume_token(IMPLEMENTATION);
      break;
      }
    case INITIALLY:{
      jj_consume_token(INITIALLY);
      break;
      }
    case INSTANTIABLE:{
      jj_consume_token(INSTANTIABLE);
      break;
      }
    case ISOYEAR:{
      jj_consume_token(ISOYEAR);
      break;
      }
    case JSON:{
      jj_consume_token(JSON);
      break;
      }
    case KEY_MEMBER:{
      jj_consume_token(KEY_MEMBER);
      break;
      }
    case LAST:{
      jj_consume_token(LAST);
      break;
      }
    case LIBRARY:{
      jj_consume_token(LIBRARY);
      break;
      }
    case MAP:{
      jj_consume_token(MAP);
      break;
      }
    case MICROSECOND:{
      jj_consume_token(MICROSECOND);
      break;
      }
    case MESSAGE_TEXT:{
      jj_consume_token(MESSAGE_TEXT);
      break;
      }
    case MINVALUE:{
      jj_consume_token(MINVALUE);
      break;
      }
    case NAME:{
      jj_consume_token(NAME);
      break;
      }
    case NESTING:{
      jj_consume_token(NESTING);
      break;
      }
    case NULLS:{
      jj_consume_token(NULLS);
      break;
      }
    case OCTETS:{
      jj_consume_token(OCTETS);
      break;
      }
    case ORDERING:{
      jj_consume_token(ORDERING);
      break;
      }
    case OUTPUT:{
      jj_consume_token(OUTPUT);
      break;
      }
    case PARAMETER_MODE:{
      jj_consume_token(PARAMETER_MODE);
      break;
      }
    case PARAMETER_SPECIFIC_CATALOG:{
      jj_consume_token(PARAMETER_SPECIFIC_CATALOG);
      break;
      }
    case PARTIAL:{
      jj_consume_token(PARTIAL);
      break;
      }
    case PASSTHROUGH:{
      jj_consume_token(PASSTHROUGH);
      break;
      }
    case PLACING:{
      jj_consume_token(PLACING);
      break;
      }
    case PRECEDING:{
      jj_consume_token(PRECEDING);
      break;
      }
    case PRIVILEGES:{
      jj_consume_token(PRIVILEGES);
      break;
      }
    case READ:{
      jj_consume_token(READ);
      break;
      }
    case REPLACE:{
      jj_consume_token(REPLACE);
      break;
      }
    case RESTRICT:{
      jj_consume_token(RESTRICT);
      break;
      }
    case RETURNED_OCTET_LENGTH:{
      jj_consume_token(RETURNED_OCTET_LENGTH);
      break;
      }
    case ROLE:{
      jj_consume_token(ROLE);
      break;
      }
    case ROUTINE_NAME:{
      jj_consume_token(ROUTINE_NAME);
      break;
      }
    case SCALAR:{
      jj_consume_token(SCALAR);
      break;
      }
    case SCHEMA_NAME:{
      jj_consume_token(SCHEMA_NAME);
      break;
      }
    case SCOPE_SCHEMA:{
      jj_consume_token(SCOPE_SCHEMA);
      break;
      }
    case SELF:{
      jj_consume_token(SELF);
      break;
      }
    case SERVER:{
      jj_consume_token(SERVER);
      break;
      }
    case SETS:{
      jj_consume_token(SETS);
      break;
      }
    case SOURCE:{
      jj_consume_token(SOURCE);
      break;
      }
    case SQL_BIGINT:{
      jj_consume_token(SQL_BIGINT);
      break;
      }
    case SQL_BLOB:{
      jj_consume_token(SQL_BLOB);
      break;
      }
    case SQL_CLOB:{
      jj_consume_token(SQL_CLOB);
      break;
      }
    case SQL_DOUBLE:{
      jj_consume_token(SQL_DOUBLE);
      break;
      }
    case SQL_INTERVAL_DAY:{
      jj_consume_token(SQL_INTERVAL_DAY);
      break;
      }
    case SQL_INTERVAL_DAY_TO_SECOND:{
      jj_consume_token(SQL_INTERVAL_DAY_TO_SECOND);
      break;
      }
    case SQL_INTERVAL_HOUR_TO_SECOND:{
      jj_consume_token(SQL_INTERVAL_HOUR_TO_SECOND);
      break;
      }
    case SQL_INTERVAL_MONTH:{
      jj_consume_token(SQL_INTERVAL_MONTH);
      break;
      }
    case SQL_INTERVAL_YEAR_TO_MONTH:{
      jj_consume_token(SQL_INTERVAL_YEAR_TO_MONTH);
      break;
      }
    case SQL_LONGVARCHAR:{
      jj_consume_token(SQL_LONGVARCHAR);
      break;
      }
    case SQL_NUMERIC:{
      jj_consume_token(SQL_NUMERIC);
      break;
      }
    case SQL_SMALLINT:{
      jj_consume_token(SQL_SMALLINT);
      break;
      }
    case SQL_TINYINT:{
      jj_consume_token(SQL_TINYINT);
      break;
      }
    case SQL_TSI_HOUR:{
      jj_consume_token(SQL_TSI_HOUR);
      break;
      }
    case SQL_TSI_MONTH:{
      jj_consume_token(SQL_TSI_MONTH);
      break;
      }
    case SQL_TSI_WEEK:{
      jj_consume_token(SQL_TSI_WEEK);
      break;
      }
    case SQL_VARCHAR:{
      jj_consume_token(SQL_VARCHAR);
      break;
      }
    case STRUCTURE:{
      jj_consume_token(STRUCTURE);
      break;
      }
    case SUBSTITUTE:{
      jj_consume_token(SUBSTITUTE);
      break;
      }
    case TIES:{
      jj_consume_token(TIES);
      break;
      }
    case TOP_LEVEL_COUNT:{
      jj_consume_token(TOP_LEVEL_COUNT);
      break;
      }
    case TRANSACTIONS_COMMITTED:{
      jj_consume_token(TRANSACTIONS_COMMITTED);
      break;
      }
    case TRANSFORMS:{
      jj_consume_token(TRANSFORMS);
      break;
      }
    case TRIGGER_SCHEMA:{
      jj_consume_token(TRIGGER_SCHEMA);
      break;
      }
    case UNCOMMITTED:{
      jj_consume_token(UNCOMMITTED);
      break;
      }
    case UNNAMED:{
      jj_consume_token(UNNAMED);
      break;
      }
    case USER_DEFINED_TYPE_CODE:{
      jj_consume_token(USER_DEFINED_TYPE_CODE);
      break;
      }
    case UTF8:{
      jj_consume_token(UTF8);
      break;
      }
    case VERSION:{
      jj_consume_token(VERSION);
      break;
      }
    case WRAPPER:{
      jj_consume_token(WRAPPER);
      break;
      }
    case XML:{
      jj_consume_token(XML);
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

/** @see #NonReservedKeyWord */
  final public void NonReservedKeyWord2of3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ABSOLUTE:{
      jj_consume_token(ABSOLUTE);
      break;
      }
    case ADD:{
      jj_consume_token(ADD);
      break;
      }
    case ALWAYS:{
      jj_consume_token(ALWAYS);
      break;
      }
    case ASSERTION:{
      jj_consume_token(ASSERTION);
      break;
      }
    case ATTRIBUTES:{
      jj_consume_token(ATTRIBUTES);
      break;
      }
    case BREADTH:{
      jj_consume_token(BREADTH);
      break;
      }
    case CATALOG:{
      jj_consume_token(CATALOG);
      break;
      }
    case CHAIN:{
      jj_consume_token(CHAIN);
      break;
      }
    case CHARACTER_SET_SCHEMA:{
      jj_consume_token(CHARACTER_SET_SCHEMA);
      break;
      }
    case CLASS_ORIGIN:{
      jj_consume_token(CLASS_ORIGIN);
      break;
      }
    case COLLATION_CATALOG:{
      jj_consume_token(COLLATION_CATALOG);
      break;
      }
    case COLUMN_NAME:{
      jj_consume_token(COLUMN_NAME);
      break;
      }
    case COMMITTED:{
      jj_consume_token(COMMITTED);
      break;
      }
    case CONNECTION:{
      jj_consume_token(CONNECTION);
      break;
      }
    case CONSTRAINT_NAME:{
      jj_consume_token(CONSTRAINT_NAME);
      break;
      }
    case CONSTRUCTOR:{
      jj_consume_token(CONSTRUCTOR);
      break;
      }
    case DATA:{
      jj_consume_token(DATA);
      break;
      }
    case DATETIME_INTERVAL_PRECISION:{
      jj_consume_token(DATETIME_INTERVAL_PRECISION);
      break;
      }
    case DEFERRABLE:{
      jj_consume_token(DEFERRABLE);
      break;
      }
    case DEFINER:{
      jj_consume_token(DEFINER);
      break;
      }
    case DERIVED:{
      jj_consume_token(DERIVED);
      break;
      }
    case DESCRIPTOR:{
      jj_consume_token(DESCRIPTOR);
      break;
      }
    case DOMAIN:{
      jj_consume_token(DOMAIN);
      break;
      }
    case DYNAMIC_FUNCTION:{
      jj_consume_token(DYNAMIC_FUNCTION);
      break;
      }
    case EPOCH:{
      jj_consume_token(EPOCH);
      break;
      }
    case EXCLUDE:{
      jj_consume_token(EXCLUDE);
      break;
      }
    case FIRST:{
      jj_consume_token(FIRST);
      break;
      }
    case FORTRAN:{
      jj_consume_token(FORTRAN);
      break;
      }
    case G:{
      jj_consume_token(G);
      break;
      }
    case GEOMETRY:{
      jj_consume_token(GEOMETRY);
      break;
      }
    case GRANTED:{
      jj_consume_token(GRANTED);
      break;
      }
    case IMMEDIATE:{
      jj_consume_token(IMMEDIATE);
      break;
      }
    case INCLUDING:{
      jj_consume_token(INCLUDING);
      break;
      }
    case INPUT:{
      jj_consume_token(INPUT);
      break;
      }
    case INVOKER:{
      jj_consume_token(INVOKER);
      break;
      }
    case ISOLATION:{
      jj_consume_token(ISOLATION);
      break;
      }
    case K:{
      jj_consume_token(K);
      break;
      }
    case KEY_TYPE:{
      jj_consume_token(KEY_TYPE);
      break;
      }
    case LENGTH:{
      jj_consume_token(LENGTH);
      break;
      }
    case LOCATOR:{
      jj_consume_token(LOCATOR);
      break;
      }
    case MATCHED:{
      jj_consume_token(MATCHED);
      break;
      }
    case MESSAGE_LENGTH:{
      jj_consume_token(MESSAGE_LENGTH);
      break;
      }
    case MILLISECOND:{
      jj_consume_token(MILLISECOND);
      break;
      }
    case MORE_:{
      jj_consume_token(MORE_);
      break;
      }
    case NAMES:{
      jj_consume_token(NAMES);
      break;
      }
    case NORMALIZED:{
      jj_consume_token(NORMALIZED);
      break;
      }
    case NUMBER:{
      jj_consume_token(NUMBER);
      break;
      }
    case OPTION:{
      jj_consume_token(OPTION);
      break;
      }
    case ORDINALITY:{
      jj_consume_token(ORDINALITY);
      break;
      }
    case OVERRIDING:{
      jj_consume_token(OVERRIDING);
      break;
      }
    case PARAMETER_NAME:{
      jj_consume_token(PARAMETER_NAME);
      break;
      }
    case PARAMETER_SPECIFIC_NAME:{
      jj_consume_token(PARAMETER_SPECIFIC_NAME);
      break;
      }
    case PASCAL:{
      jj_consume_token(PASCAL);
      break;
      }
    case PAST:{
      jj_consume_token(PAST);
      break;
      }
    case PLAN:{
      jj_consume_token(PLAN);
      break;
      }
    case PRESERVE:{
      jj_consume_token(PRESERVE);
      break;
      }
    case PUBLIC:{
      jj_consume_token(PUBLIC);
      break;
      }
    case RELATIVE:{
      jj_consume_token(RELATIVE);
      break;
      }
    case RESPECT:{
      jj_consume_token(RESPECT);
      break;
      }
    case RETURNED_CARDINALITY:{
      jj_consume_token(RETURNED_CARDINALITY);
      break;
      }
    case RETURNED_SQLSTATE:{
      jj_consume_token(RETURNED_SQLSTATE);
      break;
      }
    case ROUTINE:{
      jj_consume_token(ROUTINE);
      break;
      }
    case ROUTINE_SCHEMA:{
      jj_consume_token(ROUTINE_SCHEMA);
      break;
      }
    case SCALE:{
      jj_consume_token(SCALE);
      break;
      }
    case SCOPE_CATALOGS:{
      jj_consume_token(SCOPE_CATALOGS);
      break;
      }
    case SECTION:{
      jj_consume_token(SECTION);
      break;
      }
    case SEQUENCE:{
      jj_consume_token(SEQUENCE);
      break;
      }
    case SERVER_NAME:{
      jj_consume_token(SERVER_NAME);
      break;
      }
    case SIMPLE:{
      jj_consume_token(SIMPLE);
      break;
      }
    case SPACE:{
      jj_consume_token(SPACE);
      break;
      }
    case SQL_BINARY:{
      jj_consume_token(SQL_BINARY);
      break;
      }
    case SQL_BOOLEAN:{
      jj_consume_token(SQL_BOOLEAN);
      break;
      }
    case SQL_DATE:{
      jj_consume_token(SQL_DATE);
      break;
      }
    case SQL_FLOAT:{
      jj_consume_token(SQL_FLOAT);
      break;
      }
    case SQL_INTERVAL_DAY_TO_HOUR:{
      jj_consume_token(SQL_INTERVAL_DAY_TO_HOUR);
      break;
      }
    case SQL_INTERVAL_HOUR:{
      jj_consume_token(SQL_INTERVAL_HOUR);
      break;
      }
    case SQL_INTERVAL_MINUTE:{
      jj_consume_token(SQL_INTERVAL_MINUTE);
      break;
      }
    case SQL_INTERVAL_SECOND:{
      jj_consume_token(SQL_INTERVAL_SECOND);
      break;
      }
    case SQL_LONGVARBINARY:{
      jj_consume_token(SQL_LONGVARBINARY);
      break;
      }
    case SQL_NCHAR:{
      jj_consume_token(SQL_NCHAR);
      break;
      }
    case SQL_NVARCHAR:{
      jj_consume_token(SQL_NVARCHAR);
      break;
      }
    case SQL_TIME:{
      jj_consume_token(SQL_TIME);
      break;
      }
    case SQL_TSI_DAY:{
      jj_consume_token(SQL_TSI_DAY);
      break;
      }
    case SQL_TSI_MICROSECOND:{
      jj_consume_token(SQL_TSI_MICROSECOND);
      break;
      }
    case SQL_TSI_QUARTER:{
      jj_consume_token(SQL_TSI_QUARTER);
      break;
      }
    case SQL_TSI_YEAR:{
      jj_consume_token(SQL_TSI_YEAR);
      break;
      }
    case STATE:{
      jj_consume_token(STATE);
      break;
      }
    case STYLE:{
      jj_consume_token(STYLE);
      break;
      }
    case TABLE_NAME:{
      jj_consume_token(TABLE_NAME);
      break;
      }
    case TIMESTAMPADD:{
      jj_consume_token(TIMESTAMPADD);
      break;
      }
    case TRANSACTION:{
      jj_consume_token(TRANSACTION);
      break;
      }
    case TRANSACTIONS_ROLLED_BACK:{
      jj_consume_token(TRANSACTIONS_ROLLED_BACK);
      break;
      }
    case TRIGGER_CATALOG:{
      jj_consume_token(TRIGGER_CATALOG);
      break;
      }
    case TYPE:{
      jj_consume_token(TYPE);
      break;
      }
    case UNCONDITIONAL:{
      jj_consume_token(UNCONDITIONAL);
      break;
      }
    case USAGE:{
      jj_consume_token(USAGE);
      break;
      }
    case USER_DEFINED_TYPE_NAME:{
      jj_consume_token(USER_DEFINED_TYPE_NAME);
      break;
      }
    case UTF16:{
      jj_consume_token(UTF16);
      break;
      }
    case VIEW:{
      jj_consume_token(VIEW);
      break;
      }
    case WORK:{
      jj_consume_token(WORK);
      break;
      }
    case ZONE:{
      jj_consume_token(ZONE);
      break;
      }
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

/**
 * Defines a production which can never be accepted by the parser.
 * In effect, it tells the parser, "If you got here, you've gone too far."
 * It is used as the default production for parser extension points;
 * derived parsers replace it with a real production when they want to
 * implement a particular extension point.
 */
  final public void UnusedExtension() throws ParseException {
    if (false) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(ZONE);
}

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_3()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_4()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_5()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_6()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_7()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_8()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_9()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_10()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_11()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_12()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_3R_85()
 {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_84()
 {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_83()
 {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_77()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_83()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_84()) return false;
    jj_scanpos = xsp;
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_99()
 {
    if (jj_scan_token(APPROX_NUMERIC_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_98()
 {
    if (jj_scan_token(DECIMAL_NUMERIC_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_97()
 {
    if (jj_scan_token(UNSIGNED_INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_96()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_97()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_98()) return false;
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    return false;
  }

  private boolean jj_3R_73()
 {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_72()
 {
    if (jj_3R_80()) return true;
    return false;
  }

  private boolean jj_3R_71()
 {
    if (jj_3R_79()) return true;
    return false;
  }

  private boolean jj_3R_70()
 {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_69()
 {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_65()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_69()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_70()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_71()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_72()) return false;
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_76()
 {
    if (jj_scan_token(WHEN)) return true;
    return false;
  }

  private boolean jj_3R_75()
 {
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3R_68()
 {
    if (jj_scan_token(CASE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_76()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_8()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(504)) jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_61()
 {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_60()
 {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_63()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_scan_token(3)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(6)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(9)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(22)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(29)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(37)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(51)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(59)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(66)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(69)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(78)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(81)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(86)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(90)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(96)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(99)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(126)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(131)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(140)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(144)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(149)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(154)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(160)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(165)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(174)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(185)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(199)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(206)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(210)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(219)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(224)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(235)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(238)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(245)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(252)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(262)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(266)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(276)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(282)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(290)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(301)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(316)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(314)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(321)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(329)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(336)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(349)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(355)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(368)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(373)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(380)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(383)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(386)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(390)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(401)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(409)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(416)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(422)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(441)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(445)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(450)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(456)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(461)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(469)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(472)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(476)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(484)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(488)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(493)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(502)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(511)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(514)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(517)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(520)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(523)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(526)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(529)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(532)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(535)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(537)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(541)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(544)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(547)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(550)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(553)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(556)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(559)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(568)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(573)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(587)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(596)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(600)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(603)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(611)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(619)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(625)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(633)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(637)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(648)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(661)) return false;
    jj_scanpos = xsp;
    if (jj_scan_token(663)) return true;
    return false;
  }

  private boolean jj_3R_59()
 {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_58()
 {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_57()
 {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_53()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_57()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_58()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_59()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_60()) return false;
    jj_scanpos = xsp;
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_52()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_46()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_51()) return false;
    jj_scanpos = xsp;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_51()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_13()
 {
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3R_34()
 {
    if (jj_scan_token(PERCENT_REMAINDER)) return true;
    return false;
  }

  private boolean jj_3R_33()
 {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3R_32()
 {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_31()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_30()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_29()
 {
    if (jj_scan_token(NE2)) return true;
    return false;
  }

  private boolean jj_3R_28()
 {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_27()
 {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_26()
 {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_25()
 {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_24()
 {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_23()
 {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_15()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_23()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_24()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_25()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_26()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_27()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_28()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_29()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_30()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_31()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_32()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_33()) return false;
    jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_36()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_47()) return false;
    jj_scanpos = xsp;
    if (jj_3_6()) return true;
    return false;
  }

  private boolean jj_3R_47()
 {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_67()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_scan_token(114)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(115)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(116)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(117)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(118)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(120)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(121)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(122)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(124)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(296)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(297)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(491)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(581)) return false;
    jj_scanpos = xsp;
    if (jj_scan_token(631)) return true;
    return false;
  }

  private boolean jj_3R_62()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_scan_token(1)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(5)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(8)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(17)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(25)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(33)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(47)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(56)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(65)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(68)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(76)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(80)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(85)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(91)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(94)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(98)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(102)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(129)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(136)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(142)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(146)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(152)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(157)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(164)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(169)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(181)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(187)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(204)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(209)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(218)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(223)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(231)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(237)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(242)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(251)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(261)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(264)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(275)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(278)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(289)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(300)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(308)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(313)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(318)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(328)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(331)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(347)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(352)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(365)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(370)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(378)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(382)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(385)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(389)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(392)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(403)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(415)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(419)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(440)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(444)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(449)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(452)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(460)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(464)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(471)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(475)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(481)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(487)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(490)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(498)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(505)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(513)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(516)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(519)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(522)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(525)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(528)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(531)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(534)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(538)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(540)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(543)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(546)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(549)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(552)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(555)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(558)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(563)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(570)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(585)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(591)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(599)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(602)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(610)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(618)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(621)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(632)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(635)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(639)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(651)) return false;
    jj_scanpos = xsp;
    if (jj_scan_token(662)) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3R_56()
 {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_55()
 {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_54()
 {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_37()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3R_50()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_54()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_55()) return false;
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_17()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3_4()) return false;
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_15()) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3_5()
 {
    Token xsp;
    if (jj_3R_17()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_17()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_22()
 {
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3R_49()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_scan_token(2)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(32)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(50)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(58)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(62)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(64)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(75)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(82)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(107)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(108)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(112)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(106)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(115)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(121)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(122)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(148)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(171)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(191)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(201)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(203)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(216)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(228)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(233)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(279)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(285)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(287)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(283)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(294)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(296)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(297)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(299)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(307)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(319)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(320)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(322)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(325)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(344)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(345)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(348)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(354)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(398)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(407)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(421)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(431)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(435)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(437)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(455)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(465)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(479)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(560)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(565)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(566)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(577)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(628)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(615)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(631)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(643)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(644)) return false;
    jj_scanpos = xsp;
    if (jj_scan_token(664)) return true;
    return false;
  }

  private boolean jj_3R_39()
 {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  private boolean jj_3R_38()
 {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_19()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_38()) return false;
    jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_35()
 {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_16()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_35()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_36()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_2()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_74()
 {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_12()
 {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_66()
 {
    if (jj_3R_19()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3_12()) return false;
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_82()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_21()
 {
    if (jj_scan_token(UNSIGNED_INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_18()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_48()
 {
    if (jj_3R_20()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_9()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3_10()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_14()
 {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_45()
 {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_44()
 {
    if (jj_scan_token(UNICODE_QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_43()
 {
    if (jj_scan_token(BRACKET_QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_42()
 {
    if (jj_scan_token(BACK_QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_41()
 {
    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_40()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_20()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_40()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_41()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_42()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_43()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_44()) return false;
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_95()
 {
    if (jj_scan_token(TIMESTAMP)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_94()
 {
    if (jj_scan_token(TIME)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_93()
 {
    if (jj_scan_token(DATE)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_92()
 {
    if (jj_scan_token(LBRACE_TS)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_91()
 {
    if (jj_scan_token(LBRACE_T)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_90()
 {
    if (jj_scan_token(LBRACE_D)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_81()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_90()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_91()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_92()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_93()) return false;
    jj_scanpos = xsp;
    if (!jj_3R_94()) return false;
    jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_87()
 {
    if (jj_scan_token(DOUBLE_QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_79()
 {
    if (jj_scan_token(DOUBLE_QUOTED_STRING)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_87()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_86()
 {
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_78()
 {
    if (jj_scan_token(QUOTED_STRING)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_86()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_89()
 {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_88()
 {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_80()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_3R_88()) return false;
    jj_scanpos = xsp;
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_64()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (!jj_scan_token(4)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(7)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(14)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(24)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(30)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(45)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(55)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(60)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(67)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(72)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(79)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(84)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(88)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(93)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(97)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(100)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(128)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(132)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(141)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(145)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(151)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(155)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(162)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(168)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(179)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(186)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(200)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(208)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(217)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(220)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(226)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(236)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(241)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(248)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(259)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(263)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(274)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(277)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(288)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(298)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(303)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(312)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(317)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(326)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(330)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(342)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(350)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(364)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(369)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(377)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(381)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(384)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(388)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(391)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(402)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(412)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(418)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(438)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(443)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(448)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(451)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(459)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(462)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(470)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(474)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(480)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(486)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(489)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(497)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(503)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(512)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(515)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(518)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(521)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(524)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(527)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(530)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(533)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(536)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(539)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(542)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(545)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(548)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(551)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(554)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(557)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(562)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(569)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(583)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(590)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(598)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(601)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(609)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(616)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(620)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(630)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(634)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(638)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(650)) return false;
    jj_scanpos = xsp;
    if (!jj_scan_token(660)) return false;
    jj_scanpos = xsp;
    if (jj_scan_token(665)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public ExparserImplTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[35];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static private int[] jj_la1_8;
  static private int[] jj_la1_9;
  static private int[] jj_la1_10;
  static private int[] jj_la1_11;
  static private int[] jj_la1_12;
  static private int[] jj_la1_13;
  static private int[] jj_la1_14;
  static private int[] jj_la1_15;
  static private int[] jj_la1_16;
  static private int[] jj_la1_17;
  static private int[] jj_la1_18;
  static private int[] jj_la1_19;
  static private int[] jj_la1_20;
  static private int[] jj_la1_21;
  static private int[] jj_la1_22;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	   jj_la1_init_3();
	   jj_la1_init_4();
	   jj_la1_init_5();
	   jj_la1_init_6();
	   jj_la1_init_7();
	   jj_la1_init_8();
	   jj_la1_init_9();
	   jj_la1_init_10();
	   jj_la1_init_11();
	   jj_la1_init_12();
	   jj_la1_init_13();
	   jj_la1_init_14();
	   jj_la1_init_15();
	   jj_la1_init_16();
	   jj_la1_init_17();
	   jj_la1_init_18();
	   jj_la1_init_19();
	   jj_la1_init_20();
	   jj_la1_init_21();
	   jj_la1_init_22();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x634243fe,0x0,0x0,0x634243fa,0x634243fe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x634243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x634243fe,0x4,0x0,0x0,0x0,0x634243fa,0x2020122,0x20400248,0x41004090,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x5daca023,0x0,0x0,0x19a8a022,0x5daca023,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x5d8ca023,0x44040001,0x0,0x0,0x0,0x1988a022,0x1008002,0x8080020,0x10802000,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x6d77d93f,0x0,0x0,0x6d73d13e,0x6d77d93f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x6d77d93f,0x40801,0x0,0x0,0x0,0x6d73d13e,0x48211012,0x4424024,0x21108108,};
	}
	private static void jj_la1_init_3() {
	   jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x577d1c5f,0x0,0x0,0x577c005f,0x577d1c5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x46091c5f,0x6091c00,0x177c0000,0x0,0x0,0x4000005f,0x44,0x40000009,0x12,};
	}
	private static void jj_la1_init_4() {
	   jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x2db7711f,0x0,0x4,0x2da7711b,0x2db7711f,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x4,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x2db7711b,0x100000,0x0,0x0,0x0,0x2da7711b,0x21044102,0x4211008,0x8822011,};
	}
	private static void jj_la1_init_5() {
	   jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x8e284b35,0x0,0x0,0xe284335,0x8e284b35,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x8e284b35,0x80000800,0x0,0x0,0x0,0xe284335,0x8200210,0x2004021,0x4080104,};
	}
	private static void jj_la1_init_6() {
	   jj_la1_6 = new int[] {0x0,0x0,0x0,0x0,0x0,0x9f075b90,0x0,0x10,0x9e075180,0x9f075b90,0x0,0x0,0x10,0x0,0x0,0x10,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x9f075b80,0x1000a00,0x0,0x0,0x0,0x9e075180,0x84021000,0x8044080,0x12010100,};
	}
	private static void jj_la1_init_7() {
	   jj_la1_7 = new int[] {0x0,0x0,0x0,0x0,0x0,0x19267a95,0x0,0x0,0x19267885,0x19267a95,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x19267885,0x0,0x0,0x0,0x0,0x0,0x0,0x19267a95,0x210,0x0,0x0,0x0,0x19267885,0x8042080,0x10204801,0x1021004,};
	}
	private static void jj_la1_init_8() {
	   jj_la1_8 = new int[] {0x0,0x0,0x0,0x0,0x0,0xacfc05e8,0x0,0x0,0x47c05e8,0xacfc05e8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x47c05e8,0x0,0x0,0x0,0x0,0x0,0x0,0xacfc05e8,0xa8800000,0x0,0x0,0x0,0x47c05e8,0x480120,0x4100440,0x240088,};
	}
	private static void jj_la1_init_9() {
	   jj_la1_9 = new int[] {0x0,0x0,0x0,0x0,0x0,0xf718bf47,0x0,0x0,0x7710b707,0xf718bf47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7710b407,0x0,0x0,0x0,0x0,0x0,0x0,0xf718bf47,0x80080b40,0x300,0x0,0x0,0x7710b407,0x42101002,0x14002004,0x21008401,};
	}
	private static void jj_la1_init_10() {
	   jj_la1_10 = new int[] {0x0,0x0,0x0,0x0,0x0,0x7b410f67,0x0,0x0,0x68410f42,0x7b410f67,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x68410f42,0x0,0x0,0x0,0x4800000,0x4800000,0x0,0x7b410f67,0x13000025,0x0,0x0,0x0,0x68410f42,0x8000900,0x20010202,0x40400440,};
	}
	private static void jj_la1_init_11() {
	   jj_la1_11 = new int[] {0x0,0x0,0x0,0x0,0x0,0xf627300d,0x0,0x0,0xf6273009,0xf627300d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf6273009,0x0,0x0,0x0,0x0,0x0,0x0,0xf627300d,0x4,0x0,0x0,0x0,0xf6273009,0x44042001,0x90210008,0x22021000,};
	}
	private static void jj_la1_init_12() {
	   jj_la1_12 = new int[] {0x0,0x0,0x0,0x0,0x0,0x928e41f7,0x0,0x0,0x920e01f7,0x928e41f7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x920e01f7,0x0,0x0,0x0,0x0,0x0,0x0,0x928e41f7,0x804000,0x0,0x0,0x0,0x920e01f7,0x80080122,0x2020044,0x10040091,};
	}
	private static void jj_la1_init_13() {
	   jj_la1_13 = new int[] {0x0,0x0,0x0,0x0,0x0,0x3b68806d,0x0,0x0,0x3b40004d,0x3b68806d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3b40004d,0x0,0x0,0x0,0x0,0x0,0x0,0x3b68806d,0x288020,0x0,0x0,0x0,0x3b40004d,0x11000008,0x22000041,0x8400004,};
	}
	private static void jj_la1_init_14() {
	   jj_la1_14 = new int[] {0x0,0x0,0x0,0x0,0x0,0x9de3799f,0x0,0x0,0x1de1791f,0x9de3799f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1de1791f,0x0,0x0,0x0,0x0,0x0,0x0,0x9de3799f,0x80020080,0x0,0x0,0x0,0x1de1791f,0x8811012,0x11202104,0x4404809,};
	}
	private static void jj_la1_init_15() {
	   jj_la1_15 = new int[] {0x0,0x0,0x0,0x0,0x0,0x82c62fd3,0x0,0x0,0x82c62fd3,0x82c62fd3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x82c627d3,0x0,0x0,0x0,0x0,0x0,0x0,0x82c627d3,0x0,0x800,0x0,0x0,0x82c627d3,0x2040482,0x80402110,0x820241,};
	}
	private static void jj_la1_init_16() {
	   jj_la1_16 = new int[] {0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0xffffffff,0x94492492,0x22924924,0x49249249,};
	}
	private static void jj_la1_init_17() {
	   jj_la1_17 = new int[] {0x0,0x0,0x0,0x0,0x0,0x276dffff,0x0,0x0,0x270cffff,0x276dffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x270cffff,0x0,0x0,0x0,0x0,0x0,0x0,0x276dffff,0x610000,0x0,0x0,0x0,0x270cffff,0x4084924,0x21009249,0x2042492,};
	}
	private static void jj_la1_init_18() {
	   jj_la1_18 = new int[] {0x0,0x0,0x0,0x0,0x0,0xfd0faa2,0x0,0x3000,0xfd0caa0,0xfd0faa2,0x0,0x0,0x3000,0x0,0x0,0x0,0x0,0x0,0x3000,0xfd0ca80,0x0,0x0,0x0,0x0,0x0,0x0,0xfd0ca82,0x2,0x20,0x0,0x0,0xfd0ca80,0x4808200,0x9100800,0x2404080,};
	}
	private static void jj_la1_init_19() {
	   jj_la1_19 = new int[] {0x0,0x0,0x0,0x0,0x0,0xefd23dce,0x0,0x40,0xefc23d0e,0xefd23dce,0x0,0x0,0x40,0x0,0x0,0x40,0x0,0x0,0x0,0xef423d0e,0x0,0x0,0x0,0x0,0x0,0x0,0xefd23d8e,0x900080,0x800000,0x0,0x0,0xef423d0e,0x89002404,0x22020808,0x44401102,};
	}
	private static void jj_la1_init_20() {
	   jj_la1_20 = new int[] {0x0,0x0,0x0,0x0,0x0,0x1ff00d18,0x0,0x1c000000,0x2f00d00,0x1ff00d18,0x1000,0x0,0x1c000000,0x1c000000,0x1c000000,0x0,0x0,0x0,0x0,0x2f00d00,0x0,0x4000000,0x4000000,0x0,0x0,0x0,0x3f00d18,0x1000018,0x0,0x0,0x0,0x2f00d00,0x400800,0xa00100,0x2100400,};
	}
	private static void jj_la1_init_21() {
	   jj_la1_21 = new int[] {0x80000,0x60000000,0x8000,0xfe708000,0x1e700000,0x60000e06,0x80,0x60000e06,0x0,0x60000e86,0x0,0x0,0x60000e06,0x0,0x60000000,0x0,0x2,0x4,0xe00,0x0,0x80000,0x20000000,0x60000000,0x0,0x0,0x80,0x0,0x0,0x0,0xfe700000,0x60000000,0x0,0x0,0x0,0x0,};
	}
	private static void jj_la1_init_22() {
	   jj_la1_22 = new int[] {0x0,0x0,0x0,0x3,0x0,0x6e00000,0x0,0x0,0x6e00000,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,};
	}
  final private JJCalls[] jj_2_rtns = new JJCalls[12];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public ExparserImpl(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ExparserImpl(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new ExparserImplTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 35; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 35; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public ExparserImpl(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new ExparserImplTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 35; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new ExparserImplTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 35; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public ExparserImpl(ExparserImplTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 35; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ExparserImplTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 35; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[734];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 35; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		   if ((jj_la1_3[i] & (1<<j)) != 0) {
			 la1tokens[96+j] = true;
		   }
		   if ((jj_la1_4[i] & (1<<j)) != 0) {
			 la1tokens[128+j] = true;
		   }
		   if ((jj_la1_5[i] & (1<<j)) != 0) {
			 la1tokens[160+j] = true;
		   }
		   if ((jj_la1_6[i] & (1<<j)) != 0) {
			 la1tokens[192+j] = true;
		   }
		   if ((jj_la1_7[i] & (1<<j)) != 0) {
			 la1tokens[224+j] = true;
		   }
		   if ((jj_la1_8[i] & (1<<j)) != 0) {
			 la1tokens[256+j] = true;
		   }
		   if ((jj_la1_9[i] & (1<<j)) != 0) {
			 la1tokens[288+j] = true;
		   }
		   if ((jj_la1_10[i] & (1<<j)) != 0) {
			 la1tokens[320+j] = true;
		   }
		   if ((jj_la1_11[i] & (1<<j)) != 0) {
			 la1tokens[352+j] = true;
		   }
		   if ((jj_la1_12[i] & (1<<j)) != 0) {
			 la1tokens[384+j] = true;
		   }
		   if ((jj_la1_13[i] & (1<<j)) != 0) {
			 la1tokens[416+j] = true;
		   }
		   if ((jj_la1_14[i] & (1<<j)) != 0) {
			 la1tokens[448+j] = true;
		   }
		   if ((jj_la1_15[i] & (1<<j)) != 0) {
			 la1tokens[480+j] = true;
		   }
		   if ((jj_la1_16[i] & (1<<j)) != 0) {
			 la1tokens[512+j] = true;
		   }
		   if ((jj_la1_17[i] & (1<<j)) != 0) {
			 la1tokens[544+j] = true;
		   }
		   if ((jj_la1_18[i] & (1<<j)) != 0) {
			 la1tokens[576+j] = true;
		   }
		   if ((jj_la1_19[i] & (1<<j)) != 0) {
			 la1tokens[608+j] = true;
		   }
		   if ((jj_la1_20[i] & (1<<j)) != 0) {
			 la1tokens[640+j] = true;
		   }
		   if ((jj_la1_21[i] & (1<<j)) != 0) {
			 la1tokens[672+j] = true;
		   }
		   if ((jj_la1_22[i] & (1<<j)) != 0) {
			 la1tokens[704+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 734; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 12; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			   case 6: jj_3_7(); break;
			   case 7: jj_3_8(); break;
			   case 8: jj_3_9(); break;
			   case 9: jj_3_10(); break;
			   case 10: jj_3_11(); break;
			   case 11: jj_3_12(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}
